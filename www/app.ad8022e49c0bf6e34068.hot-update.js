webpackHotUpdate("app",{

/***/ "./node_modules/vue-meta/lib/vue-meta.js":
/*!***********************************************!*\
  !*** ./node_modules/vue-meta/lib/vue-meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * vue-meta v1.5.8\n * (c) 2018 Declan de Wet & Sébastien Chopin (@Atinux)\n * @license MIT\n */\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(typeof self !== 'undefined' ? self : this, function () { 'use strict';\n\n\t/*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/\n\t/* eslint-disable no-unused-vars */\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n\tfunction toObject(val) {\n\t\tif (val === null || val === undefined) {\n\t\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t\t}\n\n\t\treturn Object(val);\n\t}\n\n\tfunction shouldUseNative() {\n\t\ttry {\n\t\t\tif (!Object.assign) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\t\ttest1[5] = 'de';\n\t\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test2 = {};\n\t\t\tfor (var i = 0; i < 10; i++) {\n\t\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t\t}\n\t\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\t\treturn test2[n];\n\t\t\t});\n\t\t\tif (order2.join('') !== '0123456789') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test3 = {};\n\t\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\t\ttest3[letter] = letter;\n\t\t\t});\n\t\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n\t\tvar arguments$1 = arguments;\n\n\t\tvar from;\n\t\tvar to = toObject(target);\n\t\tvar symbols;\n\n\t\tfor (var s = 1; s < arguments.length; s++) {\n\t\t\tfrom = Object(arguments$1[s]);\n\n\t\t\tfor (var key in from) {\n\t\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\t\tto[key] = from[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getOwnPropertySymbols) {\n\t\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t};\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar umd = createCommonjsModule(function (module, exports) {\n\t(function (global, factory) {\n\t\tmodule.exports = factory();\n\t}(commonjsGlobal, (function () {\n\tvar isMergeableObject = function isMergeableObject(value) {\n\t\treturn isNonNullObject(value)\n\t\t\t&& !isSpecial(value)\n\t};\n\n\tfunction isNonNullObject(value) {\n\t\treturn !!value && typeof value === 'object'\n\t}\n\n\tfunction isSpecial(value) {\n\t\tvar stringValue = Object.prototype.toString.call(value);\n\n\t\treturn stringValue === '[object RegExp]'\n\t\t\t|| stringValue === '[object Date]'\n\t\t\t|| isReactElement(value)\n\t}\n\n\t// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\tvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n\tvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n\tfunction isReactElement(value) {\n\t\treturn value.$$typeof === REACT_ELEMENT_TYPE\n\t}\n\n\tfunction emptyTarget(val) {\n\t\treturn Array.isArray(val) ? [] : {}\n\t}\n\n\tfunction cloneUnlessOtherwiseSpecified(value, options) {\n\t\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t\t: value\n\t}\n\n\tfunction defaultArrayMerge(target, source, options) {\n\t\treturn target.concat(source).map(function(element) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t\t})\n\t}\n\n\tfunction mergeObject(target, source, options) {\n\t\tvar destination = {};\n\t\tif (options.isMergeableObject(target)) {\n\t\t\tObject.keys(target).forEach(function(key) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t\t});\n\t\t}\n\t\tObject.keys(source).forEach(function(key) {\n\t\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t\t} else {\n\t\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t\t}\n\t\t});\n\t\treturn destination\n\t}\n\n\tfunction deepmerge(target, source, options) {\n\t\toptions = options || {};\n\t\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\t\tvar sourceIsArray = Array.isArray(source);\n\t\tvar targetIsArray = Array.isArray(target);\n\t\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\t\tif (!sourceAndTargetTypesMatch) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t\t} else if (sourceIsArray) {\n\t\t\treturn options.arrayMerge(target, source, options)\n\t\t} else {\n\t\t\treturn mergeObject(target, source, options)\n\t\t}\n\t}\n\n\tdeepmerge.all = function deepmergeAll(array, options) {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error('first argument should be an array')\n\t\t}\n\n\t\treturn array.reduce(function(prev, next) {\n\t\t\treturn deepmerge(prev, next, options)\n\t\t}, {})\n\t};\n\n\tvar deepmerge_1 = deepmerge;\n\n\treturn deepmerge_1;\n\n\t})));\n\t});\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** `Object#toString` result references. */\n\tvar objectTag = '[object Object]';\n\n\t/**\n\t * Checks if `value` is a host object in IE < 9.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n\t */\n\tfunction isHostObject(value) {\n\t  // Many host objects are `Object` objects that can coerce to strings\n\t  // despite having improperly defined `toString` methods.\n\t  var result = false;\n\t  if (value != null && typeof value.toString != 'function') {\n\t    try {\n\t      result = !!(value + '');\n\t    } catch (e) {}\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Creates a unary function that invokes `func` with its argument transformed.\n\t *\n\t * @private\n\t * @param {Function} func The function to wrap.\n\t * @param {Function} transform The argument transform.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction overArg(func, transform) {\n\t  return function(arg) {\n\t    return func(transform(arg));\n\t  };\n\t}\n\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype,\n\t    objectProto = Object.prototype;\n\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$1 = objectProto.hasOwnProperty;\n\n\t/** Used to infer the `Object` constructor. */\n\tvar objectCtorString = funcToString.call(Object);\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString = objectProto.toString;\n\n\t/** Built-in value references. */\n\tvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\n\t/**\n\t * Checks if `value` is a plain object, that is, an object created by the\n\t * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.8.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t * }\n\t *\n\t * _.isPlainObject(new Foo);\n\t * // => false\n\t *\n\t * _.isPlainObject([1, 2, 3]);\n\t * // => false\n\t *\n\t * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t * // => true\n\t *\n\t * _.isPlainObject(Object.create(null));\n\t * // => true\n\t */\n\tfunction isPlainObject(value) {\n\t  if (!isObjectLike(value) ||\n\t      objectToString.call(value) != objectTag || isHostObject(value)) {\n\t    return false;\n\t  }\n\t  var proto = getPrototype(value);\n\t  if (proto === null) {\n\t    return true;\n\t  }\n\t  var Ctor = hasOwnProperty$1.call(proto, 'constructor') && proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\n\tvar lodash_isplainobject = isPlainObject;\n\n\t/**\n\t * checks if passed argument is an array\n\t * @param  {any}  arr - the object to check\n\t * @return {Boolean} - true if `arr` is an array\n\t */\n\tfunction isArray (arr) {\n\t  return Array.isArray\n\t    ? Array.isArray(arr)\n\t    : Object.prototype.toString.call(arr) === '[object Array]'\n\t}\n\n\tfunction uniqBy (inputArray, predicate) {\n\t  return inputArray\n\t    .filter(function (x, i, arr) { return i === arr.length - 1\n\t      ? true\n\t      : predicate(x) !== predicate(arr[i + 1]); }\n\t    )\n\t}\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY = 1 / 0;\n\n\t/** `Object#toString` result references. */\n\tvar symbolTag = '[object Symbol]';\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\n\t/** Used for built-in method references. */\n\tvar objectProto$1 = Object.prototype;\n\n\t/** Used to generate unique IDs. */\n\tvar idCounter = 0;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString$1 = objectProto$1.toString;\n\n\t/** Built-in value references. */\n\tvar Symbol$1 = root.Symbol;\n\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n\t    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n\t/**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  // Exit early for strings to avoid a performance hit in some environments.\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  if (isSymbol(value)) {\n\t    return symbolToString ? symbolToString.call(value) : '';\n\t  }\n\t  var result = (value + '');\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t}\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike$1(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike$1(value) && objectToString$1.call(value) == symbolTag);\n\t}\n\n\t/**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */\n\tfunction toString(value) {\n\t  return value == null ? '' : baseToString(value);\n\t}\n\n\t/**\n\t * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Util\n\t * @param {string} [prefix=''] The value to prefix the ID with.\n\t * @returns {string} Returns the unique ID.\n\t * @example\n\t *\n\t * _.uniqueId('contact_');\n\t * // => 'contact_104'\n\t *\n\t * _.uniqueId();\n\t * // => '105'\n\t */\n\tfunction uniqueId(prefix) {\n\t  var id = ++idCounter;\n\t  return toString(prefix) + id;\n\t}\n\n\tvar lodash_uniqueid = uniqueId;\n\n\t/**\n\t * Returns the `opts.option` $option value of the given `opts.component`.\n\t * If methods are encountered, they will be bound to the component context.\n\t * If `opts.deep` is true, will recursively merge all child component\n\t * `opts.option` $option values into the returned result.\n\t *\n\t * @param  {Object} opts - options\n\t * @param  {Object} opts.component - Vue component to fetch option data from\n\t * @param  {String} opts.option - what option to look for\n\t * @param  {Boolean} opts.deep - look for data in child components as well?\n\t * @param  {Function} opts.arrayMerge - how should arrays be merged?\n\t * @param  {Object} [result={}] - result so far\n\t * @return {Object} result - final aggregated result\n\t */\n\tfunction getComponentOption (opts, result) {\n\t  if ( result === void 0 ) result = {};\n\n\t  var component = opts.component;\n\t  var option = opts.option;\n\t  var deep = opts.deep;\n\t  var arrayMerge = opts.arrayMerge;\n\t  var metaTemplateKeyName = opts.metaTemplateKeyName;\n\t  var tagIDKeyName = opts.tagIDKeyName;\n\t  var contentKeyName = opts.contentKeyName;\n\t  var $options = component.$options;\n\n\t  if (component._inactive) { return result }\n\n\t  // only collect option data if it exists\n\t  if (typeof $options[option] !== 'undefined' && $options[option] !== null) {\n\t    var data = $options[option];\n\n\t    // if option is a function, replace it with it's result\n\t    if (typeof data === 'function') {\n\t      data = data.call(component);\n\t    }\n\n\t    if (typeof data === 'object') {\n\t      // merge with existing options\n\t      result = umd(result, data, { arrayMerge: arrayMerge });\n\t    } else {\n\t      result = data;\n\t    }\n\t  }\n\n\t  // collect & aggregate child options if deep = true\n\t  if (deep && component.$children.length) {\n\t    component.$children.forEach(function (childComponent) {\n\t      result = getComponentOption({\n\t        component: childComponent,\n\t        option: option,\n\t        deep: deep,\n\t        arrayMerge: arrayMerge\n\t      }, result);\n\t    });\n\t  }\n\t  if (metaTemplateKeyName && result.hasOwnProperty('meta')) {\n\t    result.meta = Object.keys(result.meta).map(function (metaKey) {\n\t      var metaObject = result.meta[metaKey];\n\t      if (!metaObject.hasOwnProperty(metaTemplateKeyName) || !metaObject.hasOwnProperty(contentKeyName) || typeof metaObject[metaTemplateKeyName] === 'undefined') {\n\t        return result.meta[metaKey]\n\t      }\n\n\t      var template = metaObject[metaTemplateKeyName];\n\t      delete metaObject[metaTemplateKeyName];\n\n\t      if (template) {\n\t        metaObject.content = typeof template === 'function' ? template(metaObject.content) : template.replace(/%s/g, metaObject.content);\n\t      }\n\n\t      return metaObject\n\t    });\n\t    result.meta = uniqBy(\n\t      result.meta,\n\t      function (metaObject) { return metaObject.hasOwnProperty(tagIDKeyName) ? metaObject[tagIDKeyName] : lodash_uniqueid(); }\n\t    );\n\t  }\n\t  return result\n\t}\n\n\tvar escapeHTML = function (str) { return typeof window === 'undefined'\n\t  // server-side escape sequence\n\t  ? String(str)\n\t    .replace(/&/g, '&amp;')\n\t    .replace(/</g, '&lt;')\n\t    .replace(/>/g, '&gt;')\n\t    .replace(/\"/g, '&quot;')\n\t    .replace(/'/g, '&#x27;')\n\t  // client-side escape sequence\n\t  : String(str)\n\t    .replace(/&/g, '\\u0026')\n\t    .replace(/</g, '\\u003c')\n\t    .replace(/>/g, '\\u003e')\n\t    .replace(/\"/g, '\\u0022')\n\t    .replace(/'/g, '\\u0027'); };\n\n\tfunction _getMetaInfo (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var keyName = options.keyName;\n\t  var tagIDKeyName = options.tagIDKeyName;\n\t  var metaTemplateKeyName = options.metaTemplateKeyName;\n\t  var contentKeyName = options.contentKeyName;\n\t  /**\n\t   * Returns the correct meta info for the given component\n\t   * (child components will overwrite parent meta info)\n\t   *\n\t   * @param  {Object} component - the Vue instance to get meta info from\n\t   * @return {Object} - returned meta info\n\t   */\n\t  return function getMetaInfo (component) {\n\t    // set some sane defaults\n\t    var defaultInfo = {\n\t      title: '',\n\t      titleChunk: '',\n\t      titleTemplate: '%s',\n\t      htmlAttrs: {},\n\t      bodyAttrs: {},\n\t      headAttrs: {},\n\t      meta: [],\n\t      base: [],\n\t      link: [],\n\t      style: [],\n\t      script: [],\n\t      noscript: [],\n\t      __dangerouslyDisableSanitizers: [],\n\t      __dangerouslyDisableSanitizersByTagID: {}\n\t    };\n\n\t    // collect & aggregate all metaInfo $options\n\t    var info = getComponentOption({\n\t      component: component,\n\t      option: keyName,\n\t      deep: true,\n\t      metaTemplateKeyName: metaTemplateKeyName,\n\t      tagIDKeyName: tagIDKeyName,\n\t      contentKeyName: contentKeyName,\n\t      arrayMerge: function arrayMerge (target, source) {\n\t        // we concat the arrays without merging objects contained in,\n\t        // but we check for a `vmid` property on each object in the array\n\t        // using an O(1) lookup associative array exploit\n\t        // note the use of \"for in\" - we are looping through arrays here, not\n\t        // plain objects\n\t        var destination = [];\n\t        for (var targetIndex in target) {\n\t          var targetItem = target[targetIndex];\n\t          var shared = false;\n\t          for (var sourceIndex in source) {\n\t            var sourceItem = source[sourceIndex];\n\t            if (targetItem[tagIDKeyName] && targetItem[tagIDKeyName] === sourceItem[tagIDKeyName]) {\n\t              var targetTemplate = targetItem[metaTemplateKeyName];\n\t              var sourceTemplate = sourceItem[metaTemplateKeyName];\n\t              if (targetTemplate && !sourceTemplate) {\n\t                sourceItem[contentKeyName] = applyTemplate(component)(targetTemplate)(sourceItem[contentKeyName]);\n\t              }\n\t              // If template defined in child but content in parent\n\t              if (targetTemplate && sourceTemplate && !sourceItem[contentKeyName]) {\n\t                sourceItem[contentKeyName] = applyTemplate(component)(sourceTemplate)(targetItem[contentKeyName]);\n\t                delete sourceItem[metaTemplateKeyName];\n\t              }\n\t              shared = true;\n\t              break\n\t            }\n\t          }\n\n\t          if (!shared) {\n\t            destination.push(targetItem);\n\t          }\n\t        }\n\n\t        return destination.concat(source)\n\t      }\n\t    });\n\n\t    // Remove all \"template\" tags from meta\n\n\t    // backup the title chunk in case user wants access to it\n\t    if (info.title) {\n\t      info.titleChunk = info.title;\n\t    }\n\n\t    // replace title with populated template\n\t    if (info.titleTemplate) {\n\t      info.title = applyTemplate(component)(info.titleTemplate)(info.titleChunk || '');\n\t    }\n\n\t    // convert base tag to an array so it can be handled the same way\n\t    // as the other tags\n\t    if (info.base) {\n\t      info.base = Object.keys(info.base).length ? [info.base] : [];\n\t    }\n\n\t    var ref = info.__dangerouslyDisableSanitizers;\n\t    var refByTagID = info.__dangerouslyDisableSanitizersByTagID;\n\n\t    // sanitizes potentially dangerous characters\n\t    var escape = function (info) { return Object.keys(info).reduce(function (escaped, key) {\n\t      var isDisabled = ref && ref.indexOf(key) > -1;\n\t      var tagID = info[tagIDKeyName];\n\t      if (!isDisabled && tagID) {\n\t        isDisabled = refByTagID && refByTagID[tagID] && refByTagID[tagID].indexOf(key) > -1;\n\t      }\n\t      var val = info[key];\n\t      escaped[key] = val;\n\t      if (key === '__dangerouslyDisableSanitizers' || key === '__dangerouslyDisableSanitizersByTagID') {\n\t        return escaped\n\t      }\n\t      if (!isDisabled) {\n\t        if (typeof val === 'string') {\n\t          escaped[key] = escapeHTML(val);\n\t        } else if (lodash_isplainobject(val)) {\n\t          escaped[key] = escape(val);\n\t        } else if (isArray(val)) {\n\t          escaped[key] = val.map(escape);\n\t        } else {\n\t          escaped[key] = val;\n\t        }\n\t      } else {\n\t        escaped[key] = val;\n\t      }\n\n\t      return escaped\n\t    }, {}); };\n\n\t    // merge with defaults\n\t    info = umd(defaultInfo, info);\n\n\t    // begin sanitization\n\t    info = escape(info);\n\n\t    return info\n\t  }\n\t}\n\n\tvar applyTemplate = function (component) { return function (template) { return function (chunk) { return typeof template === 'function' ? template.call(component, chunk) : template.replace(/%s/g, chunk); }; }; };\n\n\tfunction _titleGenerator (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Generates title output for the server\n\t   *\n\t   * @param  {'title'} type - the string \"title\"\n\t   * @param  {String} data - the title text\n\t   * @return {Object} - the title generator\n\t   */\n\t  return function titleGenerator (type, data) {\n\t    return {\n\t      text: function text () {\n\t        return (\"<\" + type + \" \" + attribute + \"=\\\"true\\\">\" + data + \"</\" + type + \">\")\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _attrsGenerator (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Generates tag attributes for use on the server.\n\t   *\n\t   * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n\t   * @param  {Object} data - the attributes to generate\n\t   * @return {Object} - the attribute generator\n\t   */\n\t  return function attrsGenerator (type, data) {\n\t    return {\n\t      text: function text () {\n\t        var attributeStr = '';\n\t        var watchedAttrs = [];\n\t        for (var attr in data) {\n\t          if (data.hasOwnProperty(attr)) {\n\t            watchedAttrs.push(attr);\n\t            attributeStr += (typeof data[attr] !== 'undefined'\n\t                ? (attr + \"=\\\"\" + (data[attr]) + \"\\\"\")\n\t                : attr) + \" \";\n\t          }\n\t        }\n\t        attributeStr += attribute + \"=\\\"\" + (watchedAttrs.join(',')) + \"\\\"\";\n\t        return attributeStr.trim()\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _tagGenerator (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Generates meta, base, link, style, script, noscript tags for use on the server\n\t   *\n\t   * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n\t   * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n\t   * @return {Object} - the tag generator\n\t   */\n\t  return function tagGenerator (type, tags) {\n\t    return {\n\t      text: function text (ref) {\n\t        if ( ref === void 0 ) ref = {};\n\t        var body = ref.body; if ( body === void 0 ) body = false;\n\n\t        // build a string containing all tags of this type\n\t        return tags.reduce(function (tagsStr, tag) {\n\t          if (Object.keys(tag).length === 0) { return tagsStr } // Bail on empty tag object\n\t          if (!!tag.body !== body) { return tagsStr }\n\t          // build a string containing all attributes of this tag\n\t          var attrs = Object.keys(tag).reduce(function (attrsStr, attr) {\n\t            switch (attr) {\n\t              // these attributes are treated as children on the tag\n\t              case 'innerHTML':\n\t              case 'cssText':\n\t              case 'once':\n\t                return attrsStr\n\t              // these form the attribute list for this tag\n\t              default:\n\t                if ([options.tagIDKeyName, 'body'].indexOf(attr) !== -1) {\n\t                  return (attrsStr + \" data-\" + attr + \"=\\\"\" + (tag[attr]) + \"\\\"\")\n\t                }\n\t                return typeof tag[attr] === 'undefined'\n\t                  ? (attrsStr + \" \" + attr)\n\t                  : (attrsStr + \" \" + attr + \"=\\\"\" + (tag[attr]) + \"\\\"\")\n\t            }\n\t          }, '').trim();\n\n\t          // grab child content from one of these attributes, if possible\n\t          var content = tag.innerHTML || tag.cssText || '';\n\n\t          // these tag types will have content inserted\n\t          var closed = ['noscript', 'script', 'style'].indexOf(type) === -1;\n\n\t          // generate tag exactly without any other redundant attribute\n\t          var observeTag = tag.once\n\t            ? ''\n\t            : (attribute + \"=\\\"true\\\" \");\n\n\t          // the final string for this specific tag\n\t          return closed\n\t            ? (tagsStr + \"<\" + type + \" \" + observeTag + attrs + \"/>\")\n\t            : (tagsStr + \"<\" + type + \" \" + observeTag + attrs + \">\" + content + \"</\" + type + \">\")\n\t        }, '')\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _generateServerInjector (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * Converts a meta info property to one that can be stringified on the server\n\t   *\n\t   * @param  {String} type - the type of data to convert\n\t   * @param  {(String|Object|Array<Object>)} data - the data value\n\t   * @return {Object} - the new injector\n\t   */\n\t  return function generateServerInjector (type, data) {\n\t    switch (type) {\n\t      case 'title':\n\t        return _titleGenerator(options)(type, data)\n\t      case 'htmlAttrs':\n\t      case 'bodyAttrs':\n\t      case 'headAttrs':\n\t        return _attrsGenerator(options)(type, data)\n\t      default:\n\t        return _tagGenerator(options)(type, data)\n\t    }\n\t  }\n\t}\n\n\tfunction _inject (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * Converts the state of the meta info object such that each item\n\t   * can be compiled to a tag string on the server\n\t   *\n\t   * @this {Object} - Vue instance - ideally the root component\n\t   * @return {Object} - server meta info with `toString` methods\n\t   */\n\t  return function inject () {\n\t    // get meta info with sensible defaults\n\t    var info = _getMetaInfo(options)(this.$root);\n\n\t    // generate server injectors\n\t    for (var key in info) {\n\t      if (info.hasOwnProperty(key) && key !== 'titleTemplate' && key !== 'titleChunk') {\n\t        info[key] = _generateServerInjector(options)(key, info[key]);\n\t      }\n\t    }\n\n\t    return info\n\t  }\n\t}\n\n\tfunction _updateTitle () {\n\t  /**\n\t   * Updates the document title\n\t   *\n\t   * @param  {String} title - the new title of the document\n\t   */\n\t  return function updateTitle (title) {\n\t    if ( title === void 0 ) title = document.title;\n\n\t    document.title = title;\n\t  }\n\t}\n\n\tfunction _updateTagAttributes (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Updates the document's html tag attributes\n\t   *\n\t   * @param  {Object} attrs - the new document html attributes\n\t   * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n\t   */\n\t  return function updateTagAttributes (attrs, tag) {\n\t    var vueMetaAttrString = tag.getAttribute(attribute);\n\t    var vueMetaAttrs = vueMetaAttrString ? vueMetaAttrString.split(',') : [];\n\t    var toRemove = [].concat(vueMetaAttrs);\n\t    for (var attr in attrs) {\n\t      if (attrs.hasOwnProperty(attr)) {\n\t        var val = attrs[attr] || '';\n\t        tag.setAttribute(attr, val);\n\t        if (vueMetaAttrs.indexOf(attr) === -1) {\n\t          vueMetaAttrs.push(attr);\n\t        }\n\t        var saveIndex = toRemove.indexOf(attr);\n\t        if (saveIndex !== -1) {\n\t          toRemove.splice(saveIndex, 1);\n\t        }\n\t      }\n\t    }\n\t    var i = toRemove.length - 1;\n\t    for (; i >= 0; i--) {\n\t      tag.removeAttribute(toRemove[i]);\n\t    }\n\t    if (vueMetaAttrs.length === toRemove.length) {\n\t      tag.removeAttribute(attribute);\n\t    } else {\n\t      tag.setAttribute(attribute, vueMetaAttrs.join(','));\n\t    }\n\t  }\n\t}\n\n\t// borrow the slice method\n\tvar toArray = Function.prototype.call.bind(Array.prototype.slice);\n\n\tfunction _updateTags (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n\t   * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n\t   *\n\t   * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n\t   * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n\t   * @return {Object} - a representation of what tags changed\n\t   */\n\t  return function updateTags (type, tags, headTag, bodyTag) {\n\t    var oldHeadTags = toArray(headTag.querySelectorAll((type + \"[\" + attribute + \"]\")));\n\t    var oldBodyTags = toArray(bodyTag.querySelectorAll((type + \"[\" + attribute + \"][data-body=\\\"true\\\"]\")));\n\t    var newTags = [];\n\t    var indexToDelete;\n\n\t    if (tags.length > 1) {\n\t      // remove duplicates that could have been found by merging tags\n\t      // which include a mixin with metaInfo and that mixin is used\n\t      // by multiple components on the same page\n\t      var found = [];\n\t      tags = tags.map(function (x) {\n\t        var k = JSON.stringify(x);\n\t        if (found.indexOf(k) < 0) {\n\t          found.push(k);\n\t          return x\n\t        }\n\t      }).filter(function (x) { return x; });\n\t    }\n\n\t    if (tags && tags.length) {\n\t      tags.forEach(function (tag) {\n\t        var newElement = document.createElement(type);\n\t        var oldTags = tag.body !== true ? oldHeadTags : oldBodyTags;\n\n\t        for (var attr in tag) {\n\t          if (tag.hasOwnProperty(attr)) {\n\t            if (attr === 'innerHTML') {\n\t              newElement.innerHTML = tag.innerHTML;\n\t            } else if (attr === 'cssText') {\n\t              if (newElement.styleSheet) {\n\t                newElement.styleSheet.cssText = tag.cssText;\n\t              } else {\n\t                newElement.appendChild(document.createTextNode(tag.cssText));\n\t              }\n\t            } else if ([options.tagIDKeyName, 'body'].indexOf(attr) !== -1) {\n\t              var _attr = \"data-\" + attr;\n\t              var value = (typeof tag[attr] === 'undefined') ? '' : tag[attr];\n\t              newElement.setAttribute(_attr, value);\n\t            } else {\n\t              var value$1 = (typeof tag[attr] === 'undefined') ? '' : tag[attr];\n\t              newElement.setAttribute(attr, value$1);\n\t            }\n\t          }\n\t        }\n\n\t        newElement.setAttribute(attribute, 'true');\n\n\t        // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\t        if (oldTags.some(function (existingTag, index) {\n\t          indexToDelete = index;\n\t          return newElement.isEqualNode(existingTag)\n\t        })) {\n\t          oldTags.splice(indexToDelete, 1);\n\t        } else {\n\t          newTags.push(newElement);\n\t        }\n\t      });\n\t    }\n\t    var oldTags = oldHeadTags.concat(oldBodyTags);\n\t    oldTags.forEach(function (tag) { return tag.parentNode.removeChild(tag); });\n\t    newTags.forEach(function (tag) {\n\t      if (tag.getAttribute('data-body') === 'true') {\n\t        bodyTag.appendChild(tag);\n\t      } else {\n\t        headTag.appendChild(tag);\n\t      }\n\t    });\n\n\t    return { oldTags: oldTags, newTags: newTags }\n\t  }\n\t}\n\n\tfunction _updateClientMetaInfo (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var ssrAttribute = options.ssrAttribute;\n\n\t  /**\n\t   * Performs client-side updates when new meta info is received\n\t   *\n\t   * @param  {Object} newInfo - the meta info to update to\n\t   */\n\t  return function updateClientMetaInfo (newInfo) {\n\t    var htmlTag = document.getElementsByTagName('html')[0];\n\t    // if this is not a server render, then update\n\t    if (htmlTag.getAttribute(ssrAttribute) === null) {\n\t      // initialize tracked changes\n\t      var addedTags = {};\n\t      var removedTags = {};\n\n\t      Object.keys(newInfo).forEach(function (key) {\n\t        switch (key) {\n\t          // update the title\n\t          case 'title':\n\t            _updateTitle(options)(newInfo.title);\n\t            break\n\t          // update attributes\n\t          case 'htmlAttrs':\n\t            _updateTagAttributes(options)(newInfo[key], htmlTag);\n\t            break\n\t          case 'bodyAttrs':\n\t            _updateTagAttributes(options)(newInfo[key], document.getElementsByTagName('body')[0]);\n\t            break\n\t          case 'headAttrs':\n\t            _updateTagAttributes(options)(newInfo[key], document.getElementsByTagName('head')[0]);\n\t            break\n\t          // ignore these\n\t          case 'titleChunk':\n\t          case 'titleTemplate':\n\t          case 'changed':\n\t          case '__dangerouslyDisableSanitizers':\n\t            break\n\t          // catch-all update tags\n\t          default:\n\t            var headTag = document.getElementsByTagName('head')[0];\n\t            var bodyTag = document.getElementsByTagName('body')[0];\n\t            var ref = _updateTags(options)(key, newInfo[key], headTag, bodyTag);\n\t        var oldTags = ref.oldTags;\n\t        var newTags = ref.newTags;\n\t            if (newTags.length) {\n\t              addedTags[key] = newTags;\n\t              removedTags[key] = oldTags;\n\t            }\n\t        }\n\t      });\n\n\t      // emit \"event\" with new info\n\t      if (typeof newInfo.changed === 'function') {\n\t        newInfo.changed.call(this, newInfo, addedTags, removedTags);\n\t      }\n\t    } else {\n\t      // remove the server render attribute so we can update on changes\n\t      htmlTag.removeAttribute(ssrAttribute);\n\t    }\n\t  }\n\t}\n\n\tfunction _refresh (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * When called, will update the current meta info with new meta info.\n\t   * Useful when updating meta info as the result of an asynchronous\n\t   * action that resolves after the initial render takes place.\n\t   *\n\t   * Credit to [Sébastien Chopin](https://github.com/Atinux) for the suggestion\n\t   * to implement this method.\n\t   *\n\t   * @return {Object} - new meta info\n\t   */\n\t  return function refresh () {\n\t    var info = _getMetaInfo(options)(this.$root);\n\t    _updateClientMetaInfo(options).call(this, info);\n\t    return info\n\t  }\n\t}\n\n\tfunction _$meta (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * Returns an injector for server-side rendering.\n\t   * @this {Object} - the Vue instance (a root component)\n\t   * @return {Object} - injector\n\t   */\n\t  return function $meta () {\n\t    return {\n\t      inject: _inject(options).bind(this),\n\t      refresh: _refresh(options).bind(this)\n\t    }\n\t  }\n\t}\n\n\t// fallback to timers if rAF not present\n\tvar stopUpdate = (typeof window !== 'undefined' ? window.cancelAnimationFrame : null) || clearTimeout;\n\tvar startUpdate = (typeof window !== 'undefined' ? window.requestAnimationFrame : null) || (function (cb) { return setTimeout(cb, 0); });\n\n\t/**\n\t * Performs a batched update. Uses requestAnimationFrame to prevent\n\t * calling a function too many times in quick succession.\n\t * You need to pass it an ID (which can initially be `null`),\n\t * but be sure to overwrite that ID with the return value of batchUpdate.\n\t *\n\t * @param  {(null|Number)} id - the ID of this update\n\t * @param  {Function} callback - the update to perform\n\t * @return {Number} id - a new ID\n\t */\n\tfunction batchUpdate (id, callback) {\n\t  stopUpdate(id);\n\t  return startUpdate(function () {\n\t    id = null;\n\t    callback();\n\t  })\n\t}\n\n\t/**\n\t * These are constant variables used throughout the application.\n\t */\n\n\t// This is the name of the component option that contains all the information that\n\t// gets converted to the various meta tags & attributes for the page.\n\tvar VUE_META_KEY_NAME = 'metaInfo';\n\n\t// This is the attribute vue-meta augments on elements to know which it should\n\t// manage and which it should ignore.\n\tvar VUE_META_ATTRIBUTE = 'data-vue-meta';\n\n\t// This is the attribute that goes on the `html` tag to inform `vue-meta`\n\t// that the server has already generated the meta tags for the initial render.\n\tvar VUE_META_SERVER_RENDERED_ATTRIBUTE = 'data-vue-meta-server-rendered';\n\n\t// This is the property that tells vue-meta to overwrite (instead of append)\n\t// an item in a tag list. For example, if you have two `meta` tag list items\n\t// that both have `vmid` of \"description\", then vue-meta will overwrite the\n\t// shallowest one with the deepest one.\n\tvar VUE_META_TAG_LIST_ID_KEY_NAME = 'vmid';\n\n\t// This is the key name for possible meta templates\n\tvar VUE_META_TEMPLATE_KEY_NAME = 'template';\n\n\t// This is the key name for the content-holding property\n\tvar VUE_META_CONTENT_KEY = 'content';\n\n\t// automatic install\n\tif (typeof window !== 'undefined' && typeof window.Vue !== 'undefined') {\n\t  Vue.use(VueMeta);\n\t}\n\n\t/**\n\t * Plugin install function.\n\t * @param {Function} Vue - the Vue constructor.\n\t */\n\tfunction VueMeta (Vue, options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  // set some default options\n\t  var defaultOptions = {\n\t    keyName: VUE_META_KEY_NAME,\n\t    contentKeyName: VUE_META_CONTENT_KEY,\n\t    metaTemplateKeyName: VUE_META_TEMPLATE_KEY_NAME,\n\t    attribute: VUE_META_ATTRIBUTE,\n\t    ssrAttribute: VUE_META_SERVER_RENDERED_ATTRIBUTE,\n\t    tagIDKeyName: VUE_META_TAG_LIST_ID_KEY_NAME\n\t  };\n\t  // combine options\n\t  options = objectAssign(defaultOptions, options);\n\n\t  // bind the $meta method to this component instance\n\t  Vue.prototype.$meta = _$meta(options);\n\n\t  // store an id to keep track of DOM updates\n\t  var batchID = null;\n\n\t  // watch for client side component updates\n\t  Vue.mixin({\n\t    beforeCreate: function beforeCreate () {\n\t      // Add a marker to know if it uses metaInfo\n\t      // _vnode is used to know that it's attached to a real component\n\t      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\t      if (typeof this.$options[options.keyName] !== 'undefined') {\n\t        this._hasMetaInfo = true;\n\t      }\n\t      // coerce function-style metaInfo to a computed prop so we can observe\n\t      // it on creation\n\t      if (typeof this.$options[options.keyName] === 'function') {\n\t        if (typeof this.$options.computed === 'undefined') {\n\t          this.$options.computed = {};\n\t        }\n\t        this.$options.computed.$metaInfo = this.$options[options.keyName];\n\t      }\n\t    },\n\t    created: function created () {\n\t      var this$1 = this;\n\n\t      // if computed $metaInfo exists, watch it for updates & trigger a refresh\n\t      // when it changes (i.e. automatically handle async actions that affect metaInfo)\n\t      // credit for this suggestion goes to [Sébastien Chopin](https://github.com/Atinux)\n\t      if (!this.$isServer && this.$metaInfo) {\n\t        this.$watch('$metaInfo', function () {\n\t          // batch potential DOM updates to prevent extraneous re-rendering\n\t          batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t        });\n\t      }\n\t    },\n\t    activated: function activated () {\n\t      var this$1 = this;\n\n\t      if (this._hasMetaInfo) {\n\t        // batch potential DOM updates to prevent extraneous re-rendering\n\t        batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t      }\n\t    },\n\t    deactivated: function deactivated () {\n\t      var this$1 = this;\n\n\t      if (this._hasMetaInfo) {\n\t        // batch potential DOM updates to prevent extraneous re-rendering\n\t        batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t      }\n\t    },\n\t    beforeMount: function beforeMount () {\n\t      var this$1 = this;\n\n\t      // batch potential DOM updates to prevent extraneous re-rendering\n\t      if (this._hasMetaInfo) {\n\t        batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t      }\n\t    },\n\t    destroyed: function destroyed () {\n\t      var this$1 = this;\n\n\t      // do not trigger refresh on the server side\n\t      if (this.$isServer) { return }\n\t      // re-render meta data when returning from a child component to parent\n\t      if (this._hasMetaInfo) {\n\t        // Wait that element is hidden before refreshing meta tags (to support animations)\n\t        var interval = setInterval(function () {\n\t          if (this$1.$el && this$1.$el.offsetParent !== null) { return }\n\t          clearInterval(interval);\n\t          if (!this$1.$parent) { return }\n\t          batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t        }, 50);\n\t      }\n\t    }\n\t  });\n\t}\n\n\tvar version = \"1.5.8\";\n\n\tVueMeta.version = version;\n\n\treturn VueMeta;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLW1ldGEvbGliL3Z1ZS1tZXRhLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1tZXRhL2xpYi92dWUtbWV0YS5qcz8wYTg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdnVlLW1ldGEgdjEuNS44XG4gKiAoYykgMjAxOCBEZWNsYW4gZGUgV2V0ICYgU8OpYmFzdGllbiBDaG9waW4gKEBBdGludXgpXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHRnbG9iYWwuVnVlTWV0YSA9IGZhY3RvcnkoKTtcbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qXG5cdG9iamVjdC1hc3NpZ25cblx0KGMpIFNpbmRyZSBTb3JodXNcblx0QGxpY2Vuc2UgTUlUXG5cdCovXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblx0ZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gT2JqZWN0KHZhbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdFx0dmFyIHRlc3QyID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHZhciBvYmplY3RBc3NpZ24gPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cblx0XHR2YXIgZnJvbTtcblx0XHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHRcdHZhciBzeW1ib2xzO1xuXG5cdFx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzJDFbc10pO1xuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdG87XG5cdH07XG5cblx0dmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIHVtZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fShjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uICgpIHtcblx0dmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0XHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcblx0fTtcblxuXHRmdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0XHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG5cdH1cblxuXHRmdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0XHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdFx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG5cdH1cblxuXHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcblx0dmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblx0dmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuXHRmdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG5cdH1cblxuXHRmdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHRcdDogdmFsdWVcblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdFx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0T2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGlmICghb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkgfHwgIXRhcmdldFtrZXldKSB7XG5cdFx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZGVlcG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGRlc3RpbmF0aW9uXG5cdH1cblxuXHRmdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdFx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cblx0XHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0XHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0XHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0XHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdFx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdFx0fVxuXHR9XG5cblx0ZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRcdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0XHR9LCB7fSlcblx0fTtcblxuXHR2YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cblx0cmV0dXJuIGRlZXBtZXJnZV8xO1xuXG5cdH0pKSk7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG5cdCAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuXHQgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cblx0ICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuXHQgKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuXHQgKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcblx0ICovXG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG5cdCAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3Ncblx0ICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuXHQgIHZhciByZXN1bHQgPSBmYWxzZTtcblx0ICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuXHQgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcblx0ICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcblx0ICB9O1xuXHR9XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblx0dmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG5cdHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG5cdCAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKHt9KTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG5cdCAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcblx0ICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjguMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogZnVuY3Rpb24gRm9vKCkge1xuXHQgKiAgIHRoaXMuYSA9IDE7XG5cdCAqIH1cblx0ICpcblx0ICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG5cdCAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8XG5cdCAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG5cdCAgaWYgKHByb3RvID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHQgIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuXHQgICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG5cdH1cblxuXHR2YXIgbG9kYXNoX2lzcGxhaW5vYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuXG5cdC8qKlxuXHQgKiBjaGVja3MgaWYgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGFycmF5XG5cdCAqIEBwYXJhbSAge2FueX0gIGFyciAtIHRoZSBvYmplY3QgdG8gY2hlY2tcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGBhcnJgIGlzIGFuIGFycmF5XG5cdCAqL1xuXHRmdW5jdGlvbiBpc0FycmF5IChhcnIpIHtcblx0ICByZXR1cm4gQXJyYXkuaXNBcnJheVxuXHQgICAgPyBBcnJheS5pc0FycmF5KGFycilcblx0ICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSdcblx0fVxuXG5cdGZ1bmN0aW9uIHVuaXFCeSAoaW5wdXRBcnJheSwgcHJlZGljYXRlKSB7XG5cdCAgcmV0dXJuIGlucHV0QXJyYXlcblx0ICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgsIGksIGFycikgeyByZXR1cm4gaSA9PT0gYXJyLmxlbmd0aCAtIDFcblx0ICAgICAgPyB0cnVlXG5cdCAgICAgIDogcHJlZGljYXRlKHgpICE9PSBwcmVkaWNhdGUoYXJyW2kgKyAxXSk7IH1cblx0ICAgIClcblx0fVxuXG5cdC8qKlxuXHQgKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG5cdCAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuXHQgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cblx0ICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuXHQgKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuXHQgKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcblx0ICovXG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG5cdHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG5cdC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXHR2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuXHR2YXIgaWRDb3VudGVyID0gMDtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90byQxLnRvU3RyaW5nO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgU3ltYm9sJDEgPSByb290LlN5bWJvbDtcblxuXHQvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cblx0dmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuXHQgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG5cdCAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cblx0ICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG5cdCAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuXHQgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSQxKHZhbHVlKSB7XG5cdCAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woJ2FiYycpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG5cdCAgICAoaXNPYmplY3RMaWtlJDEodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuXHQgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvU3RyaW5nKG51bGwpO1xuXHQgKiAvLyA9PiAnJ1xuXHQgKlxuXHQgKiBfLnRvU3RyaW5nKC0wKTtcblx0ICogLy8gPT4gJy0wJ1xuXHQgKlxuXHQgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG5cdCAqIC8vID0+ICcxLDIsMydcblx0ICovXG5cdGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAY2F0ZWdvcnkgVXRpbFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuXHQgKiAvLyA9PiAnY29udGFjdF8xMDQnXG5cdCAqXG5cdCAqIF8udW5pcXVlSWQoKTtcblx0ICogLy8gPT4gJzEwNSdcblx0ICovXG5cdGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuXHQgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuXHQgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG5cdH1cblxuXHR2YXIgbG9kYXNoX3VuaXF1ZWlkID0gdW5pcXVlSWQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGBvcHRzLm9wdGlvbmAgJG9wdGlvbiB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYG9wdHMuY29tcG9uZW50YC5cblx0ICogSWYgbWV0aG9kcyBhcmUgZW5jb3VudGVyZWQsIHRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgY29tcG9uZW50IGNvbnRleHQuXG5cdCAqIElmIGBvcHRzLmRlZXBgIGlzIHRydWUsIHdpbGwgcmVjdXJzaXZlbHkgbWVyZ2UgYWxsIGNoaWxkIGNvbXBvbmVudFxuXHQgKiBgb3B0cy5vcHRpb25gICRvcHRpb24gdmFsdWVzIGludG8gdGhlIHJldHVybmVkIHJlc3VsdC5cblx0ICpcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMuY29tcG9uZW50IC0gVnVlIGNvbXBvbmVudCB0byBmZXRjaCBvcHRpb24gZGF0YSBmcm9tXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gb3B0cy5vcHRpb24gLSB3aGF0IG9wdGlvbiB0byBsb29rIGZvclxuXHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRzLmRlZXAgLSBsb29rIGZvciBkYXRhIGluIGNoaWxkIGNvbXBvbmVudHMgYXMgd2VsbD9cblx0ICogQHBhcmFtICB7RnVuY3Rpb259IG9wdHMuYXJyYXlNZXJnZSAtIGhvdyBzaG91bGQgYXJyYXlzIGJlIG1lcmdlZD9cblx0ICogQHBhcmFtICB7T2JqZWN0fSBbcmVzdWx0PXt9XSAtIHJlc3VsdCBzbyBmYXJcblx0ICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQgLSBmaW5hbCBhZ2dyZWdhdGVkIHJlc3VsdFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q29tcG9uZW50T3B0aW9uIChvcHRzLCByZXN1bHQpIHtcblx0ICBpZiAoIHJlc3VsdCA9PT0gdm9pZCAwICkgcmVzdWx0ID0ge307XG5cblx0ICB2YXIgY29tcG9uZW50ID0gb3B0cy5jb21wb25lbnQ7XG5cdCAgdmFyIG9wdGlvbiA9IG9wdHMub3B0aW9uO1xuXHQgIHZhciBkZWVwID0gb3B0cy5kZWVwO1xuXHQgIHZhciBhcnJheU1lcmdlID0gb3B0cy5hcnJheU1lcmdlO1xuXHQgIHZhciBtZXRhVGVtcGxhdGVLZXlOYW1lID0gb3B0cy5tZXRhVGVtcGxhdGVLZXlOYW1lO1xuXHQgIHZhciB0YWdJREtleU5hbWUgPSBvcHRzLnRhZ0lES2V5TmFtZTtcblx0ICB2YXIgY29udGVudEtleU5hbWUgPSBvcHRzLmNvbnRlbnRLZXlOYW1lO1xuXHQgIHZhciAkb3B0aW9ucyA9IGNvbXBvbmVudC4kb3B0aW9ucztcblxuXHQgIGlmIChjb21wb25lbnQuX2luYWN0aXZlKSB7IHJldHVybiByZXN1bHQgfVxuXG5cdCAgLy8gb25seSBjb2xsZWN0IG9wdGlvbiBkYXRhIGlmIGl0IGV4aXN0c1xuXHQgIGlmICh0eXBlb2YgJG9wdGlvbnNbb3B0aW9uXSAhPT0gJ3VuZGVmaW5lZCcgJiYgJG9wdGlvbnNbb3B0aW9uXSAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGRhdGEgPSAkb3B0aW9uc1tvcHRpb25dO1xuXG5cdCAgICAvLyBpZiBvcHRpb24gaXMgYSBmdW5jdGlvbiwgcmVwbGFjZSBpdCB3aXRoIGl0J3MgcmVzdWx0XG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgZGF0YSA9IGRhdGEuY2FsbChjb21wb25lbnQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIC8vIG1lcmdlIHdpdGggZXhpc3Rpbmcgb3B0aW9uc1xuXHQgICAgICByZXN1bHQgPSB1bWQocmVzdWx0LCBkYXRhLCB7IGFycmF5TWVyZ2U6IGFycmF5TWVyZ2UgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSBkYXRhO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIGNvbGxlY3QgJiBhZ2dyZWdhdGUgY2hpbGQgb3B0aW9ucyBpZiBkZWVwID0gdHJ1ZVxuXHQgIGlmIChkZWVwICYmIGNvbXBvbmVudC4kY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdCAgICBjb21wb25lbnQuJGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkQ29tcG9uZW50KSB7XG5cdCAgICAgIHJlc3VsdCA9IGdldENvbXBvbmVudE9wdGlvbih7XG5cdCAgICAgICAgY29tcG9uZW50OiBjaGlsZENvbXBvbmVudCxcblx0ICAgICAgICBvcHRpb246IG9wdGlvbixcblx0ICAgICAgICBkZWVwOiBkZWVwLFxuXHQgICAgICAgIGFycmF5TWVyZ2U6IGFycmF5TWVyZ2Vcblx0ICAgICAgfSwgcmVzdWx0KTtcblx0ICAgIH0pO1xuXHQgIH1cblx0ICBpZiAobWV0YVRlbXBsYXRlS2V5TmFtZSAmJiByZXN1bHQuaGFzT3duUHJvcGVydHkoJ21ldGEnKSkge1xuXHQgICAgcmVzdWx0Lm1ldGEgPSBPYmplY3Qua2V5cyhyZXN1bHQubWV0YSkubWFwKGZ1bmN0aW9uIChtZXRhS2V5KSB7XG5cdCAgICAgIHZhciBtZXRhT2JqZWN0ID0gcmVzdWx0Lm1ldGFbbWV0YUtleV07XG5cdCAgICAgIGlmICghbWV0YU9iamVjdC5oYXNPd25Qcm9wZXJ0eShtZXRhVGVtcGxhdGVLZXlOYW1lKSB8fCAhbWV0YU9iamVjdC5oYXNPd25Qcm9wZXJ0eShjb250ZW50S2V5TmFtZSkgfHwgdHlwZW9mIG1ldGFPYmplY3RbbWV0YVRlbXBsYXRlS2V5TmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXRhW21ldGFLZXldXG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdGVtcGxhdGUgPSBtZXRhT2JqZWN0W21ldGFUZW1wbGF0ZUtleU5hbWVdO1xuXHQgICAgICBkZWxldGUgbWV0YU9iamVjdFttZXRhVGVtcGxhdGVLZXlOYW1lXTtcblxuXHQgICAgICBpZiAodGVtcGxhdGUpIHtcblx0ICAgICAgICBtZXRhT2JqZWN0LmNvbnRlbnQgPSB0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicgPyB0ZW1wbGF0ZShtZXRhT2JqZWN0LmNvbnRlbnQpIDogdGVtcGxhdGUucmVwbGFjZSgvJXMvZywgbWV0YU9iamVjdC5jb250ZW50KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBtZXRhT2JqZWN0XG5cdCAgICB9KTtcblx0ICAgIHJlc3VsdC5tZXRhID0gdW5pcUJ5KFxuXHQgICAgICByZXN1bHQubWV0YSxcblx0ICAgICAgZnVuY3Rpb24gKG1ldGFPYmplY3QpIHsgcmV0dXJuIG1ldGFPYmplY3QuaGFzT3duUHJvcGVydHkodGFnSURLZXlOYW1lKSA/IG1ldGFPYmplY3RbdGFnSURLZXlOYW1lXSA6IGxvZGFzaF91bmlxdWVpZCgpOyB9XG5cdCAgICApO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0XG5cdH1cblxuXHR2YXIgZXNjYXBlSFRNTCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5cdCAgLy8gc2VydmVyLXNpZGUgZXNjYXBlIHNlcXVlbmNlXG5cdCAgPyBTdHJpbmcoc3RyKVxuXHQgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0ICAgIC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0ICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0ICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jylcblx0ICAgIC5yZXBsYWNlKC8nL2csICcmI3gyNzsnKVxuXHQgIC8vIGNsaWVudC1zaWRlIGVzY2FwZSBzZXF1ZW5jZVxuXHQgIDogU3RyaW5nKHN0cilcblx0ICAgIC5yZXBsYWNlKC8mL2csICdcXHUwMDI2Jylcblx0ICAgIC5yZXBsYWNlKC88L2csICdcXHUwMDNjJylcblx0ICAgIC5yZXBsYWNlKC8+L2csICdcXHUwMDNlJylcblx0ICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MDAyMicpXG5cdCAgICAucmVwbGFjZSgvJy9nLCAnXFx1MDAyNycpOyB9O1xuXG5cdGZ1bmN0aW9uIF9nZXRNZXRhSW5mbyAob3B0aW9ucykge1xuXHQgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgdmFyIGtleU5hbWUgPSBvcHRpb25zLmtleU5hbWU7XG5cdCAgdmFyIHRhZ0lES2V5TmFtZSA9IG9wdGlvbnMudGFnSURLZXlOYW1lO1xuXHQgIHZhciBtZXRhVGVtcGxhdGVLZXlOYW1lID0gb3B0aW9ucy5tZXRhVGVtcGxhdGVLZXlOYW1lO1xuXHQgIHZhciBjb250ZW50S2V5TmFtZSA9IG9wdGlvbnMuY29udGVudEtleU5hbWU7XG5cdCAgLyoqXG5cdCAgICogUmV0dXJucyB0aGUgY29ycmVjdCBtZXRhIGluZm8gZm9yIHRoZSBnaXZlbiBjb21wb25lbnRcblx0ICAgKiAoY2hpbGQgY29tcG9uZW50cyB3aWxsIG92ZXJ3cml0ZSBwYXJlbnQgbWV0YSBpbmZvKVxuXHQgICAqXG5cdCAgICogQHBhcmFtICB7T2JqZWN0fSBjb21wb25lbnQgLSB0aGUgVnVlIGluc3RhbmNlIHRvIGdldCBtZXRhIGluZm8gZnJvbVxuXHQgICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5lZCBtZXRhIGluZm9cblx0ICAgKi9cblx0ICByZXR1cm4gZnVuY3Rpb24gZ2V0TWV0YUluZm8gKGNvbXBvbmVudCkge1xuXHQgICAgLy8gc2V0IHNvbWUgc2FuZSBkZWZhdWx0c1xuXHQgICAgdmFyIGRlZmF1bHRJbmZvID0ge1xuXHQgICAgICB0aXRsZTogJycsXG5cdCAgICAgIHRpdGxlQ2h1bms6ICcnLFxuXHQgICAgICB0aXRsZVRlbXBsYXRlOiAnJXMnLFxuXHQgICAgICBodG1sQXR0cnM6IHt9LFxuXHQgICAgICBib2R5QXR0cnM6IHt9LFxuXHQgICAgICBoZWFkQXR0cnM6IHt9LFxuXHQgICAgICBtZXRhOiBbXSxcblx0ICAgICAgYmFzZTogW10sXG5cdCAgICAgIGxpbms6IFtdLFxuXHQgICAgICBzdHlsZTogW10sXG5cdCAgICAgIHNjcmlwdDogW10sXG5cdCAgICAgIG5vc2NyaXB0OiBbXSxcblx0ICAgICAgX19kYW5nZXJvdXNseURpc2FibGVTYW5pdGl6ZXJzOiBbXSxcblx0ICAgICAgX19kYW5nZXJvdXNseURpc2FibGVTYW5pdGl6ZXJzQnlUYWdJRDoge31cblx0ICAgIH07XG5cblx0ICAgIC8vIGNvbGxlY3QgJiBhZ2dyZWdhdGUgYWxsIG1ldGFJbmZvICRvcHRpb25zXG5cdCAgICB2YXIgaW5mbyA9IGdldENvbXBvbmVudE9wdGlvbih7XG5cdCAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuXHQgICAgICBvcHRpb246IGtleU5hbWUsXG5cdCAgICAgIGRlZXA6IHRydWUsXG5cdCAgICAgIG1ldGFUZW1wbGF0ZUtleU5hbWU6IG1ldGFUZW1wbGF0ZUtleU5hbWUsXG5cdCAgICAgIHRhZ0lES2V5TmFtZTogdGFnSURLZXlOYW1lLFxuXHQgICAgICBjb250ZW50S2V5TmFtZTogY29udGVudEtleU5hbWUsXG5cdCAgICAgIGFycmF5TWVyZ2U6IGZ1bmN0aW9uIGFycmF5TWVyZ2UgKHRhcmdldCwgc291cmNlKSB7XG5cdCAgICAgICAgLy8gd2UgY29uY2F0IHRoZSBhcnJheXMgd2l0aG91dCBtZXJnaW5nIG9iamVjdHMgY29udGFpbmVkIGluLFxuXHQgICAgICAgIC8vIGJ1dCB3ZSBjaGVjayBmb3IgYSBgdm1pZGAgcHJvcGVydHkgb24gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5XG5cdCAgICAgICAgLy8gdXNpbmcgYW4gTygxKSBsb29rdXAgYXNzb2NpYXRpdmUgYXJyYXkgZXhwbG9pdFxuXHQgICAgICAgIC8vIG5vdGUgdGhlIHVzZSBvZiBcImZvciBpblwiIC0gd2UgYXJlIGxvb3BpbmcgdGhyb3VnaCBhcnJheXMgaGVyZSwgbm90XG5cdCAgICAgICAgLy8gcGxhaW4gb2JqZWN0c1xuXHQgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIHRhcmdldEluZGV4IGluIHRhcmdldCkge1xuXHQgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbdGFyZ2V0SW5kZXhdO1xuXHQgICAgICAgICAgdmFyIHNoYXJlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgZm9yICh2YXIgc291cmNlSW5kZXggaW4gc291cmNlKSB7XG5cdCAgICAgICAgICAgIHZhciBzb3VyY2VJdGVtID0gc291cmNlW3NvdXJjZUluZGV4XTtcblx0ICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW1bdGFnSURLZXlOYW1lXSAmJiB0YXJnZXRJdGVtW3RhZ0lES2V5TmFtZV0gPT09IHNvdXJjZUl0ZW1bdGFnSURLZXlOYW1lXSkge1xuXHQgICAgICAgICAgICAgIHZhciB0YXJnZXRUZW1wbGF0ZSA9IHRhcmdldEl0ZW1bbWV0YVRlbXBsYXRlS2V5TmFtZV07XG5cdCAgICAgICAgICAgICAgdmFyIHNvdXJjZVRlbXBsYXRlID0gc291cmNlSXRlbVttZXRhVGVtcGxhdGVLZXlOYW1lXTtcblx0ICAgICAgICAgICAgICBpZiAodGFyZ2V0VGVtcGxhdGUgJiYgIXNvdXJjZVRlbXBsYXRlKSB7XG5cdCAgICAgICAgICAgICAgICBzb3VyY2VJdGVtW2NvbnRlbnRLZXlOYW1lXSA9IGFwcGx5VGVtcGxhdGUoY29tcG9uZW50KSh0YXJnZXRUZW1wbGF0ZSkoc291cmNlSXRlbVtjb250ZW50S2V5TmFtZV0pO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAvLyBJZiB0ZW1wbGF0ZSBkZWZpbmVkIGluIGNoaWxkIGJ1dCBjb250ZW50IGluIHBhcmVudFxuXHQgICAgICAgICAgICAgIGlmICh0YXJnZXRUZW1wbGF0ZSAmJiBzb3VyY2VUZW1wbGF0ZSAmJiAhc291cmNlSXRlbVtjb250ZW50S2V5TmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZUl0ZW1bY29udGVudEtleU5hbWVdID0gYXBwbHlUZW1wbGF0ZShjb21wb25lbnQpKHNvdXJjZVRlbXBsYXRlKSh0YXJnZXRJdGVtW2NvbnRlbnRLZXlOYW1lXSk7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgc291cmNlSXRlbVttZXRhVGVtcGxhdGVLZXlOYW1lXTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgc2hhcmVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICBicmVha1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICghc2hhcmVkKSB7XG5cdCAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2godGFyZ2V0SXRlbSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uLmNvbmNhdChzb3VyY2UpXG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvLyBSZW1vdmUgYWxsIFwidGVtcGxhdGVcIiB0YWdzIGZyb20gbWV0YVxuXG5cdCAgICAvLyBiYWNrdXAgdGhlIHRpdGxlIGNodW5rIGluIGNhc2UgdXNlciB3YW50cyBhY2Nlc3MgdG8gaXRcblx0ICAgIGlmIChpbmZvLnRpdGxlKSB7XG5cdCAgICAgIGluZm8udGl0bGVDaHVuayA9IGluZm8udGl0bGU7XG5cdCAgICB9XG5cblx0ICAgIC8vIHJlcGxhY2UgdGl0bGUgd2l0aCBwb3B1bGF0ZWQgdGVtcGxhdGVcblx0ICAgIGlmIChpbmZvLnRpdGxlVGVtcGxhdGUpIHtcblx0ICAgICAgaW5mby50aXRsZSA9IGFwcGx5VGVtcGxhdGUoY29tcG9uZW50KShpbmZvLnRpdGxlVGVtcGxhdGUpKGluZm8udGl0bGVDaHVuayB8fCAnJyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGNvbnZlcnQgYmFzZSB0YWcgdG8gYW4gYXJyYXkgc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlIHNhbWUgd2F5XG5cdCAgICAvLyBhcyB0aGUgb3RoZXIgdGFnc1xuXHQgICAgaWYgKGluZm8uYmFzZSkge1xuXHQgICAgICBpbmZvLmJhc2UgPSBPYmplY3Qua2V5cyhpbmZvLmJhc2UpLmxlbmd0aCA/IFtpbmZvLmJhc2VdIDogW107XG5cdCAgICB9XG5cblx0ICAgIHZhciByZWYgPSBpbmZvLl9fZGFuZ2Vyb3VzbHlEaXNhYmxlU2FuaXRpemVycztcblx0ICAgIHZhciByZWZCeVRhZ0lEID0gaW5mby5fX2Rhbmdlcm91c2x5RGlzYWJsZVNhbml0aXplcnNCeVRhZ0lEO1xuXG5cdCAgICAvLyBzYW5pdGl6ZXMgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNoYXJhY3RlcnNcblx0ICAgIHZhciBlc2NhcGUgPSBmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gT2JqZWN0LmtleXMoaW5mbykucmVkdWNlKGZ1bmN0aW9uIChlc2NhcGVkLCBrZXkpIHtcblx0ICAgICAgdmFyIGlzRGlzYWJsZWQgPSByZWYgJiYgcmVmLmluZGV4T2Yoa2V5KSA+IC0xO1xuXHQgICAgICB2YXIgdGFnSUQgPSBpbmZvW3RhZ0lES2V5TmFtZV07XG5cdCAgICAgIGlmICghaXNEaXNhYmxlZCAmJiB0YWdJRCkge1xuXHQgICAgICAgIGlzRGlzYWJsZWQgPSByZWZCeVRhZ0lEICYmIHJlZkJ5VGFnSURbdGFnSURdICYmIHJlZkJ5VGFnSURbdGFnSURdLmluZGV4T2Yoa2V5KSA+IC0xO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciB2YWwgPSBpbmZvW2tleV07XG5cdCAgICAgIGVzY2FwZWRba2V5XSA9IHZhbDtcblx0ICAgICAgaWYgKGtleSA9PT0gJ19fZGFuZ2Vyb3VzbHlEaXNhYmxlU2FuaXRpemVycycgfHwga2V5ID09PSAnX19kYW5nZXJvdXNseURpc2FibGVTYW5pdGl6ZXJzQnlUYWdJRCcpIHtcblx0ICAgICAgICByZXR1cm4gZXNjYXBlZFxuXHQgICAgICB9XG5cdCAgICAgIGlmICghaXNEaXNhYmxlZCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgZXNjYXBlZFtrZXldID0gZXNjYXBlSFRNTCh2YWwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobG9kYXNoX2lzcGxhaW5vYmplY3QodmFsKSkge1xuXHQgICAgICAgICAgZXNjYXBlZFtrZXldID0gZXNjYXBlKHZhbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcblx0ICAgICAgICAgIGVzY2FwZWRba2V5XSA9IHZhbC5tYXAoZXNjYXBlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZXNjYXBlZFtrZXldID0gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlc2NhcGVkW2tleV0gPSB2YWw7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZXNjYXBlZFxuXHQgICAgfSwge30pOyB9O1xuXG5cdCAgICAvLyBtZXJnZSB3aXRoIGRlZmF1bHRzXG5cdCAgICBpbmZvID0gdW1kKGRlZmF1bHRJbmZvLCBpbmZvKTtcblxuXHQgICAgLy8gYmVnaW4gc2FuaXRpemF0aW9uXG5cdCAgICBpbmZvID0gZXNjYXBlKGluZm8pO1xuXG5cdCAgICByZXR1cm4gaW5mb1xuXHQgIH1cblx0fVxuXG5cdHZhciBhcHBseVRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBvbmVudCkgeyByZXR1cm4gZnVuY3Rpb24gKHRlbXBsYXRlKSB7IHJldHVybiBmdW5jdGlvbiAoY2h1bmspIHsgcmV0dXJuIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHRlbXBsYXRlLmNhbGwoY29tcG9uZW50LCBjaHVuaykgOiB0ZW1wbGF0ZS5yZXBsYWNlKC8lcy9nLCBjaHVuayk7IH07IH07IH07XG5cblx0ZnVuY3Rpb24gX3RpdGxlR2VuZXJhdG9yIChvcHRpb25zKSB7XG5cdCAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cblx0ICB2YXIgYXR0cmlidXRlID0gb3B0aW9ucy5hdHRyaWJ1dGU7XG5cblx0ICAvKipcblx0ICAgKiBHZW5lcmF0ZXMgdGl0bGUgb3V0cHV0IGZvciB0aGUgc2VydmVyXG5cdCAgICpcblx0ICAgKiBAcGFyYW0gIHsndGl0bGUnfSB0eXBlIC0gdGhlIHN0cmluZyBcInRpdGxlXCJcblx0ICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgLSB0aGUgdGl0bGUgdGV4dFxuXHQgICAqIEByZXR1cm4ge09iamVjdH0gLSB0aGUgdGl0bGUgZ2VuZXJhdG9yXG5cdCAgICovXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHRpdGxlR2VuZXJhdG9yICh0eXBlLCBkYXRhKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0ICgpIHtcblx0ICAgICAgICByZXR1cm4gKFwiPFwiICsgdHlwZSArIFwiIFwiICsgYXR0cmlidXRlICsgXCI9XFxcInRydWVcXFwiPlwiICsgZGF0YSArIFwiPC9cIiArIHR5cGUgKyBcIj5cIilcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9hdHRyc0dlbmVyYXRvciAob3B0aW9ucykge1xuXHQgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgdmFyIGF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlO1xuXG5cdCAgLyoqXG5cdCAgICogR2VuZXJhdGVzIHRhZyBhdHRyaWJ1dGVzIGZvciB1c2Ugb24gdGhlIHNlcnZlci5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSAgeygnYm9keUF0dHJzJ3wnaHRtbEF0dHJzJ3wnaGVhZEF0dHJzJyl9IHR5cGUgLSB0aGUgdHlwZSBvZiBhdHRyaWJ1dGVzIHRvIGdlbmVyYXRlXG5cdCAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIC0gdGhlIGF0dHJpYnV0ZXMgdG8gZ2VuZXJhdGVcblx0ICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIGF0dHJpYnV0ZSBnZW5lcmF0b3Jcblx0ICAgKi9cblx0ICByZXR1cm4gZnVuY3Rpb24gYXR0cnNHZW5lcmF0b3IgKHR5cGUsIGRhdGEpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQgKCkge1xuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVTdHIgPSAnJztcblx0ICAgICAgICB2YXIgd2F0Y2hlZEF0dHJzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBkYXRhKSB7XG5cdCAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuXHQgICAgICAgICAgICB3YXRjaGVkQXR0cnMucHVzaChhdHRyKTtcblx0ICAgICAgICAgICAgYXR0cmlidXRlU3RyICs9ICh0eXBlb2YgZGF0YVthdHRyXSAhPT0gJ3VuZGVmaW5lZCdcblx0ICAgICAgICAgICAgICAgID8gKGF0dHIgKyBcIj1cXFwiXCIgKyAoZGF0YVthdHRyXSkgKyBcIlxcXCJcIilcblx0ICAgICAgICAgICAgICAgIDogYXR0cikgKyBcIiBcIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgYXR0cmlidXRlU3RyICs9IGF0dHJpYnV0ZSArIFwiPVxcXCJcIiArICh3YXRjaGVkQXR0cnMuam9pbignLCcpKSArIFwiXFxcIlwiO1xuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVTdHIudHJpbSgpXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBfdGFnR2VuZXJhdG9yIChvcHRpb25zKSB7XG5cdCAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cblx0ICB2YXIgYXR0cmlidXRlID0gb3B0aW9ucy5hdHRyaWJ1dGU7XG5cblx0ICAvKipcblx0ICAgKiBHZW5lcmF0ZXMgbWV0YSwgYmFzZSwgbGluaywgc3R5bGUsIHNjcmlwdCwgbm9zY3JpcHQgdGFncyBmb3IgdXNlIG9uIHRoZSBzZXJ2ZXJcblx0ICAgKlxuXHQgICAqIEBwYXJhbSAgeygnbWV0YSd8J2Jhc2UnfCdsaW5rJ3wnc3R5bGUnfCdzY3JpcHQnfCdub3NjcmlwdCcpfSB0aGUgbmFtZSBvZiB0aGUgdGFnXG5cdCAgICogQHBhcmFtICB7KEFycmF5PE9iamVjdD58T2JqZWN0KX0gdGFncyAtIGFuIGFycmF5IG9mIHRhZyBvYmplY3RzIG9yIGEgc2luZ2xlIG9iamVjdCBpbiBjYXNlIG9mIGJhc2Vcblx0ICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIHRhZyBnZW5lcmF0b3Jcblx0ICAgKi9cblx0ICByZXR1cm4gZnVuY3Rpb24gdGFnR2VuZXJhdG9yICh0eXBlLCB0YWdzKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0IChyZWYpIHtcblx0ICAgICAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG5cdCAgICAgICAgdmFyIGJvZHkgPSByZWYuYm9keTsgaWYgKCBib2R5ID09PSB2b2lkIDAgKSBib2R5ID0gZmFsc2U7XG5cblx0ICAgICAgICAvLyBidWlsZCBhIHN0cmluZyBjb250YWluaW5nIGFsbCB0YWdzIG9mIHRoaXMgdHlwZVxuXHQgICAgICAgIHJldHVybiB0YWdzLnJlZHVjZShmdW5jdGlvbiAodGFnc1N0ciwgdGFnKSB7XG5cdCAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGFnKS5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRhZ3NTdHIgfSAvLyBCYWlsIG9uIGVtcHR5IHRhZyBvYmplY3Rcblx0ICAgICAgICAgIGlmICghIXRhZy5ib2R5ICE9PSBib2R5KSB7IHJldHVybiB0YWdzU3RyIH1cblx0ICAgICAgICAgIC8vIGJ1aWxkIGEgc3RyaW5nIGNvbnRhaW5pbmcgYWxsIGF0dHJpYnV0ZXMgb2YgdGhpcyB0YWdcblx0ICAgICAgICAgIHZhciBhdHRycyA9IE9iamVjdC5rZXlzKHRhZykucmVkdWNlKGZ1bmN0aW9uIChhdHRyc1N0ciwgYXR0cikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcblx0ICAgICAgICAgICAgICAvLyB0aGVzZSBhdHRyaWJ1dGVzIGFyZSB0cmVhdGVkIGFzIGNoaWxkcmVuIG9uIHRoZSB0YWdcblx0ICAgICAgICAgICAgICBjYXNlICdpbm5lckhUTUwnOlxuXHQgICAgICAgICAgICAgIGNhc2UgJ2Nzc1RleHQnOlxuXHQgICAgICAgICAgICAgIGNhc2UgJ29uY2UnOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzU3RyXG5cdCAgICAgICAgICAgICAgLy8gdGhlc2UgZm9ybSB0aGUgYXR0cmlidXRlIGxpc3QgZm9yIHRoaXMgdGFnXG5cdCAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGlmIChbb3B0aW9ucy50YWdJREtleU5hbWUsICdib2R5J10uaW5kZXhPZihhdHRyKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIChhdHRyc1N0ciArIFwiIGRhdGEtXCIgKyBhdHRyICsgXCI9XFxcIlwiICsgKHRhZ1thdHRyXSkgKyBcIlxcXCJcIilcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGFnW2F0dHJdID09PSAndW5kZWZpbmVkJ1xuXHQgICAgICAgICAgICAgICAgICA/IChhdHRyc1N0ciArIFwiIFwiICsgYXR0cilcblx0ICAgICAgICAgICAgICAgICAgOiAoYXR0cnNTdHIgKyBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyAodGFnW2F0dHJdKSArIFwiXFxcIlwiKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9LCAnJykudHJpbSgpO1xuXG5cdCAgICAgICAgICAvLyBncmFiIGNoaWxkIGNvbnRlbnQgZnJvbSBvbmUgb2YgdGhlc2UgYXR0cmlidXRlcywgaWYgcG9zc2libGVcblx0ICAgICAgICAgIHZhciBjb250ZW50ID0gdGFnLmlubmVySFRNTCB8fCB0YWcuY3NzVGV4dCB8fCAnJztcblxuXHQgICAgICAgICAgLy8gdGhlc2UgdGFnIHR5cGVzIHdpbGwgaGF2ZSBjb250ZW50IGluc2VydGVkXG5cdCAgICAgICAgICB2YXIgY2xvc2VkID0gWydub3NjcmlwdCcsICdzY3JpcHQnLCAnc3R5bGUnXS5pbmRleE9mKHR5cGUpID09PSAtMTtcblxuXHQgICAgICAgICAgLy8gZ2VuZXJhdGUgdGFnIGV4YWN0bHkgd2l0aG91dCBhbnkgb3RoZXIgcmVkdW5kYW50IGF0dHJpYnV0ZVxuXHQgICAgICAgICAgdmFyIG9ic2VydmVUYWcgPSB0YWcub25jZVxuXHQgICAgICAgICAgICA/ICcnXG5cdCAgICAgICAgICAgIDogKGF0dHJpYnV0ZSArIFwiPVxcXCJ0cnVlXFxcIiBcIik7XG5cblx0ICAgICAgICAgIC8vIHRoZSBmaW5hbCBzdHJpbmcgZm9yIHRoaXMgc3BlY2lmaWMgdGFnXG5cdCAgICAgICAgICByZXR1cm4gY2xvc2VkXG5cdCAgICAgICAgICAgID8gKHRhZ3NTdHIgKyBcIjxcIiArIHR5cGUgKyBcIiBcIiArIG9ic2VydmVUYWcgKyBhdHRycyArIFwiLz5cIilcblx0ICAgICAgICAgICAgOiAodGFnc1N0ciArIFwiPFwiICsgdHlwZSArIFwiIFwiICsgb2JzZXJ2ZVRhZyArIGF0dHJzICsgXCI+XCIgKyBjb250ZW50ICsgXCI8L1wiICsgdHlwZSArIFwiPlwiKVxuXHQgICAgICAgIH0sICcnKVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gX2dlbmVyYXRlU2VydmVySW5qZWN0b3IgKG9wdGlvbnMpIHtcblx0ICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgIC8qKlxuXHQgICAqIENvbnZlcnRzIGEgbWV0YSBpbmZvIHByb3BlcnR5IHRvIG9uZSB0aGF0IGNhbiBiZSBzdHJpbmdpZmllZCBvbiB0aGUgc2VydmVyXG5cdCAgICpcblx0ICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgLSB0aGUgdHlwZSBvZiBkYXRhIHRvIGNvbnZlcnRcblx0ICAgKiBAcGFyYW0gIHsoU3RyaW5nfE9iamVjdHxBcnJheTxPYmplY3Q+KX0gZGF0YSAtIHRoZSBkYXRhIHZhbHVlXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSAtIHRoZSBuZXcgaW5qZWN0b3Jcblx0ICAgKi9cblx0ICByZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGVTZXJ2ZXJJbmplY3RvciAodHlwZSwgZGF0YSkge1xuXHQgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgIGNhc2UgJ3RpdGxlJzpcblx0ICAgICAgICByZXR1cm4gX3RpdGxlR2VuZXJhdG9yKG9wdGlvbnMpKHR5cGUsIGRhdGEpXG5cdCAgICAgIGNhc2UgJ2h0bWxBdHRycyc6XG5cdCAgICAgIGNhc2UgJ2JvZHlBdHRycyc6XG5cdCAgICAgIGNhc2UgJ2hlYWRBdHRycyc6XG5cdCAgICAgICAgcmV0dXJuIF9hdHRyc0dlbmVyYXRvcihvcHRpb25zKSh0eXBlLCBkYXRhKVxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHJldHVybiBfdGFnR2VuZXJhdG9yKG9wdGlvbnMpKHR5cGUsIGRhdGEpXG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gX2luamVjdCAob3B0aW9ucykge1xuXHQgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgLyoqXG5cdCAgICogQ29udmVydHMgdGhlIHN0YXRlIG9mIHRoZSBtZXRhIGluZm8gb2JqZWN0IHN1Y2ggdGhhdCBlYWNoIGl0ZW1cblx0ICAgKiBjYW4gYmUgY29tcGlsZWQgdG8gYSB0YWcgc3RyaW5nIG9uIHRoZSBzZXJ2ZXJcblx0ICAgKlxuXHQgICAqIEB0aGlzIHtPYmplY3R9IC0gVnVlIGluc3RhbmNlIC0gaWRlYWxseSB0aGUgcm9vdCBjb21wb25lbnRcblx0ICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gc2VydmVyIG1ldGEgaW5mbyB3aXRoIGB0b1N0cmluZ2AgbWV0aG9kc1xuXHQgICAqL1xuXHQgIHJldHVybiBmdW5jdGlvbiBpbmplY3QgKCkge1xuXHQgICAgLy8gZ2V0IG1ldGEgaW5mbyB3aXRoIHNlbnNpYmxlIGRlZmF1bHRzXG5cdCAgICB2YXIgaW5mbyA9IF9nZXRNZXRhSW5mbyhvcHRpb25zKSh0aGlzLiRyb290KTtcblxuXHQgICAgLy8gZ2VuZXJhdGUgc2VydmVyIGluamVjdG9yc1xuXHQgICAgZm9yICh2YXIga2V5IGluIGluZm8pIHtcblx0ICAgICAgaWYgKGluZm8uaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICd0aXRsZVRlbXBsYXRlJyAmJiBrZXkgIT09ICd0aXRsZUNodW5rJykge1xuXHQgICAgICAgIGluZm9ba2V5XSA9IF9nZW5lcmF0ZVNlcnZlckluamVjdG9yKG9wdGlvbnMpKGtleSwgaW5mb1trZXldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaW5mb1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIF91cGRhdGVUaXRsZSAoKSB7XG5cdCAgLyoqXG5cdCAgICogVXBkYXRlcyB0aGUgZG9jdW1lbnQgdGl0bGVcblx0ICAgKlxuXHQgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgLSB0aGUgbmV3IHRpdGxlIG9mIHRoZSBkb2N1bWVudFxuXHQgICAqL1xuXHQgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVUaXRsZSAodGl0bGUpIHtcblx0ICAgIGlmICggdGl0bGUgPT09IHZvaWQgMCApIHRpdGxlID0gZG9jdW1lbnQudGl0bGU7XG5cblx0ICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gX3VwZGF0ZVRhZ0F0dHJpYnV0ZXMgKG9wdGlvbnMpIHtcblx0ICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgIHZhciBhdHRyaWJ1dGUgPSBvcHRpb25zLmF0dHJpYnV0ZTtcblxuXHQgIC8qKlxuXHQgICAqIFVwZGF0ZXMgdGhlIGRvY3VtZW50J3MgaHRtbCB0YWcgYXR0cmlidXRlc1xuXHQgICAqXG5cdCAgICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyAtIHRoZSBuZXcgZG9jdW1lbnQgaHRtbCBhdHRyaWJ1dGVzXG5cdCAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhZyAtIHRoZSBIVE1MRWxlbWVudCB0YWcgdG8gdXBkYXRlIHdpdGggbmV3IGF0dHJzXG5cdCAgICovXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVRhZ0F0dHJpYnV0ZXMgKGF0dHJzLCB0YWcpIHtcblx0ICAgIHZhciB2dWVNZXRhQXR0clN0cmluZyA9IHRhZy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0ICAgIHZhciB2dWVNZXRhQXR0cnMgPSB2dWVNZXRhQXR0clN0cmluZyA/IHZ1ZU1ldGFBdHRyU3RyaW5nLnNwbGl0KCcsJykgOiBbXTtcblx0ICAgIHZhciB0b1JlbW92ZSA9IFtdLmNvbmNhdCh2dWVNZXRhQXR0cnMpO1xuXHQgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuXHQgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcblx0ICAgICAgICB2YXIgdmFsID0gYXR0cnNbYXR0cl0gfHwgJyc7XG5cdCAgICAgICAgdGFnLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpO1xuXHQgICAgICAgIGlmICh2dWVNZXRhQXR0cnMuaW5kZXhPZihhdHRyKSA9PT0gLTEpIHtcblx0ICAgICAgICAgIHZ1ZU1ldGFBdHRycy5wdXNoKGF0dHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc2F2ZUluZGV4ID0gdG9SZW1vdmUuaW5kZXhPZihhdHRyKTtcblx0ICAgICAgICBpZiAoc2F2ZUluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgdG9SZW1vdmUuc3BsaWNlKHNhdmVJbmRleCwgMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgaSA9IHRvUmVtb3ZlLmxlbmd0aCAtIDE7XG5cdCAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSh0b1JlbW92ZVtpXSk7XG5cdCAgICB9XG5cdCAgICBpZiAodnVlTWV0YUF0dHJzLmxlbmd0aCA9PT0gdG9SZW1vdmUubGVuZ3RoKSB7XG5cdCAgICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2dWVNZXRhQXR0cnMuam9pbignLCcpKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvLyBib3Jyb3cgdGhlIHNsaWNlIG1ldGhvZFxuXHR2YXIgdG9BcnJheSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxuXHRmdW5jdGlvbiBfdXBkYXRlVGFncyAob3B0aW9ucykge1xuXHQgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgdmFyIGF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlO1xuXG5cdCAgLyoqXG5cdCAgICogVXBkYXRlcyBtZXRhIHRhZ3MgaW5zaWRlIDxoZWFkPiBhbmQgPGJvZHk+IG9uIHRoZSBjbGllbnQuIEJvcnJvd2VkIGZyb20gYHJlYWN0LWhlbG1ldGA6XG5cdCAgICogaHR0cHM6Ly9naXRodWIuY29tL25mbC9yZWFjdC1oZWxtZXQvYmxvYi8wMDRkNDQ4ZjhkZTVmODIzZDEwZjgzOGIwMjMxNzUyMTE4MGYzNGRhL3NyYy9IZWxtZXQuanMjTDE5NS1MMjQ1XG5cdCAgICpcblx0ICAgKiBAcGFyYW0gIHsoJ21ldGEnfCdiYXNlJ3wnbGluayd8J3N0eWxlJ3wnc2NyaXB0J3wnbm9zY3JpcHQnKX0gdHlwZSAtIHRoZSBuYW1lIG9mIHRoZSB0YWdcblx0ICAgKiBAcGFyYW0gIHsoQXJyYXk8T2JqZWN0PnxPYmplY3QpfSB0YWdzIC0gYW4gYXJyYXkgb2YgdGFnIG9iamVjdHMgb3IgYSBzaW5nbGUgb2JqZWN0IGluIGNhc2Ugb2YgYmFzZVxuXHQgICAqIEByZXR1cm4ge09iamVjdH0gLSBhIHJlcHJlc2VudGF0aW9uIG9mIHdoYXQgdGFncyBjaGFuZ2VkXG5cdCAgICovXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVRhZ3MgKHR5cGUsIHRhZ3MsIGhlYWRUYWcsIGJvZHlUYWcpIHtcblx0ICAgIHZhciBvbGRIZWFkVGFncyA9IHRvQXJyYXkoaGVhZFRhZy5xdWVyeVNlbGVjdG9yQWxsKCh0eXBlICsgXCJbXCIgKyBhdHRyaWJ1dGUgKyBcIl1cIikpKTtcblx0ICAgIHZhciBvbGRCb2R5VGFncyA9IHRvQXJyYXkoYm9keVRhZy5xdWVyeVNlbGVjdG9yQWxsKCh0eXBlICsgXCJbXCIgKyBhdHRyaWJ1dGUgKyBcIl1bZGF0YS1ib2R5PVxcXCJ0cnVlXFxcIl1cIikpKTtcblx0ICAgIHZhciBuZXdUYWdzID0gW107XG5cdCAgICB2YXIgaW5kZXhUb0RlbGV0ZTtcblxuXHQgICAgaWYgKHRhZ3MubGVuZ3RoID4gMSkge1xuXHQgICAgICAvLyByZW1vdmUgZHVwbGljYXRlcyB0aGF0IGNvdWxkIGhhdmUgYmVlbiBmb3VuZCBieSBtZXJnaW5nIHRhZ3Ncblx0ICAgICAgLy8gd2hpY2ggaW5jbHVkZSBhIG1peGluIHdpdGggbWV0YUluZm8gYW5kIHRoYXQgbWl4aW4gaXMgdXNlZFxuXHQgICAgICAvLyBieSBtdWx0aXBsZSBjb21wb25lbnRzIG9uIHRoZSBzYW1lIHBhZ2Vcblx0ICAgICAgdmFyIGZvdW5kID0gW107XG5cdCAgICAgIHRhZ3MgPSB0YWdzLm1hcChmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgIHZhciBrID0gSlNPTi5zdHJpbmdpZnkoeCk7XG5cdCAgICAgICAgaWYgKGZvdW5kLmluZGV4T2YoaykgPCAwKSB7XG5cdCAgICAgICAgICBmb3VuZC5wdXNoKGspO1xuXHQgICAgICAgICAgcmV0dXJuIHhcblx0ICAgICAgICB9XG5cdCAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0YWdzICYmIHRhZ3MubGVuZ3RoKSB7XG5cdCAgICAgIHRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG5cdCAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHQgICAgICAgIHZhciBvbGRUYWdzID0gdGFnLmJvZHkgIT09IHRydWUgPyBvbGRIZWFkVGFncyA6IG9sZEJvZHlUYWdzO1xuXG5cdCAgICAgICAgZm9yICh2YXIgYXR0ciBpbiB0YWcpIHtcblx0ICAgICAgICAgIGlmICh0YWcuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcblx0ICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdpbm5lckhUTUwnKSB7XG5cdCAgICAgICAgICAgICAgbmV3RWxlbWVudC5pbm5lckhUTUwgPSB0YWcuaW5uZXJIVE1MO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09ICdjc3NUZXh0Jykge1xuXHQgICAgICAgICAgICAgIGlmIChuZXdFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0ICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGFnLmNzc1RleHQ7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGFnLmNzc1RleHQpKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoW29wdGlvbnMudGFnSURLZXlOYW1lLCAnYm9keSddLmluZGV4T2YoYXR0cikgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgdmFyIF9hdHRyID0gXCJkYXRhLVwiICsgYXR0cjtcblx0ICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAodHlwZW9mIHRhZ1thdHRyXSA9PT0gJ3VuZGVmaW5lZCcpID8gJycgOiB0YWdbYXR0cl07XG5cdCAgICAgICAgICAgICAgbmV3RWxlbWVudC5zZXRBdHRyaWJ1dGUoX2F0dHIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB2YXIgdmFsdWUkMSA9ICh0eXBlb2YgdGFnW2F0dHJdID09PSAndW5kZWZpbmVkJykgPyAnJyA6IHRhZ1thdHRyXTtcblx0ICAgICAgICAgICAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSQxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5ld0VsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgJ3RydWUnKTtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBhIGR1cGxpY2F0ZSB0YWcgZnJvbSBkb21UYWdzdG9SZW1vdmUsIHNvIGl0IGlzbid0IGNsZWFyZWQuXG5cdCAgICAgICAgaWYgKG9sZFRhZ3Muc29tZShmdW5jdGlvbiAoZXhpc3RpbmdUYWcsIGluZGV4KSB7XG5cdCAgICAgICAgICBpbmRleFRvRGVsZXRlID0gaW5kZXg7XG5cdCAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudC5pc0VxdWFsTm9kZShleGlzdGluZ1RhZylcblx0ICAgICAgICB9KSkge1xuXHQgICAgICAgICAgb2xkVGFncy5zcGxpY2UoaW5kZXhUb0RlbGV0ZSwgMSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG5ld1RhZ3MucHVzaChuZXdFbGVtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdmFyIG9sZFRhZ3MgPSBvbGRIZWFkVGFncy5jb25jYXQob2xkQm9keVRhZ3MpO1xuXHQgICAgb2xkVGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7IH0pO1xuXHQgICAgbmV3VGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcblx0ICAgICAgaWYgKHRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYm9keScpID09PSAndHJ1ZScpIHtcblx0ICAgICAgICBib2R5VGFnLmFwcGVuZENoaWxkKHRhZyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaGVhZFRhZy5hcHBlbmRDaGlsZCh0YWcpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIHsgb2xkVGFnczogb2xkVGFncywgbmV3VGFnczogbmV3VGFncyB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gX3VwZGF0ZUNsaWVudE1ldGFJbmZvIChvcHRpb25zKSB7XG5cdCAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cblx0ICB2YXIgc3NyQXR0cmlidXRlID0gb3B0aW9ucy5zc3JBdHRyaWJ1dGU7XG5cblx0ICAvKipcblx0ICAgKiBQZXJmb3JtcyBjbGllbnQtc2lkZSB1cGRhdGVzIHdoZW4gbmV3IG1ldGEgaW5mbyBpcyByZWNlaXZlZFxuXHQgICAqXG5cdCAgICogQHBhcmFtICB7T2JqZWN0fSBuZXdJbmZvIC0gdGhlIG1ldGEgaW5mbyB0byB1cGRhdGUgdG9cblx0ICAgKi9cblx0ICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlQ2xpZW50TWV0YUluZm8gKG5ld0luZm8pIHtcblx0ICAgIHZhciBodG1sVGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXTtcblx0ICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgc2VydmVyIHJlbmRlciwgdGhlbiB1cGRhdGVcblx0ICAgIGlmIChodG1sVGFnLmdldEF0dHJpYnV0ZShzc3JBdHRyaWJ1dGUpID09PSBudWxsKSB7XG5cdCAgICAgIC8vIGluaXRpYWxpemUgdHJhY2tlZCBjaGFuZ2VzXG5cdCAgICAgIHZhciBhZGRlZFRhZ3MgPSB7fTtcblx0ICAgICAgdmFyIHJlbW92ZWRUYWdzID0ge307XG5cblx0ICAgICAgT2JqZWN0LmtleXMobmV3SW5mbykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgc3dpdGNoIChrZXkpIHtcblx0ICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdGl0bGVcblx0ICAgICAgICAgIGNhc2UgJ3RpdGxlJzpcblx0ICAgICAgICAgICAgX3VwZGF0ZVRpdGxlKG9wdGlvbnMpKG5ld0luZm8udGl0bGUpO1xuXHQgICAgICAgICAgICBicmVha1xuXHQgICAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcblx0ICAgICAgICAgIGNhc2UgJ2h0bWxBdHRycyc6XG5cdCAgICAgICAgICAgIF91cGRhdGVUYWdBdHRyaWJ1dGVzKG9wdGlvbnMpKG5ld0luZm9ba2V5XSwgaHRtbFRhZyk7XG5cdCAgICAgICAgICAgIGJyZWFrXG5cdCAgICAgICAgICBjYXNlICdib2R5QXR0cnMnOlxuXHQgICAgICAgICAgICBfdXBkYXRlVGFnQXR0cmlidXRlcyhvcHRpb25zKShuZXdJbmZvW2tleV0sIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0pO1xuXHQgICAgICAgICAgICBicmVha1xuXHQgICAgICAgICAgY2FzZSAnaGVhZEF0dHJzJzpcblx0ICAgICAgICAgICAgX3VwZGF0ZVRhZ0F0dHJpYnV0ZXMob3B0aW9ucykobmV3SW5mb1trZXldLCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKTtcblx0ICAgICAgICAgICAgYnJlYWtcblx0ICAgICAgICAgIC8vIGlnbm9yZSB0aGVzZVxuXHQgICAgICAgICAgY2FzZSAndGl0bGVDaHVuayc6XG5cdCAgICAgICAgICBjYXNlICd0aXRsZVRlbXBsYXRlJzpcblx0ICAgICAgICAgIGNhc2UgJ2NoYW5nZWQnOlxuXHQgICAgICAgICAgY2FzZSAnX19kYW5nZXJvdXNseURpc2FibGVTYW5pdGl6ZXJzJzpcblx0ICAgICAgICAgICAgYnJlYWtcblx0ICAgICAgICAgIC8vIGNhdGNoLWFsbCB1cGRhdGUgdGFnc1xuXHQgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdmFyIGhlYWRUYWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHQgICAgICAgICAgICB2YXIgYm9keVRhZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG5cdCAgICAgICAgICAgIHZhciByZWYgPSBfdXBkYXRlVGFncyhvcHRpb25zKShrZXksIG5ld0luZm9ba2V5XSwgaGVhZFRhZywgYm9keVRhZyk7XG5cdCAgICAgICAgdmFyIG9sZFRhZ3MgPSByZWYub2xkVGFncztcblx0ICAgICAgICB2YXIgbmV3VGFncyA9IHJlZi5uZXdUYWdzO1xuXHQgICAgICAgICAgICBpZiAobmV3VGFncy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICBhZGRlZFRhZ3Nba2V5XSA9IG5ld1RhZ3M7XG5cdCAgICAgICAgICAgICAgcmVtb3ZlZFRhZ3Nba2V5XSA9IG9sZFRhZ3M7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIC8vIGVtaXQgXCJldmVudFwiIHdpdGggbmV3IGluZm9cblx0ICAgICAgaWYgKHR5cGVvZiBuZXdJbmZvLmNoYW5nZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBuZXdJbmZvLmNoYW5nZWQuY2FsbCh0aGlzLCBuZXdJbmZvLCBhZGRlZFRhZ3MsIHJlbW92ZWRUYWdzKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyIGF0dHJpYnV0ZSBzbyB3ZSBjYW4gdXBkYXRlIG9uIGNoYW5nZXNcblx0ICAgICAgaHRtbFRhZy5yZW1vdmVBdHRyaWJ1dGUoc3NyQXR0cmlidXRlKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBfcmVmcmVzaCAob3B0aW9ucykge1xuXHQgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgLyoqXG5cdCAgICogV2hlbiBjYWxsZWQsIHdpbGwgdXBkYXRlIHRoZSBjdXJyZW50IG1ldGEgaW5mbyB3aXRoIG5ldyBtZXRhIGluZm8uXG5cdCAgICogVXNlZnVsIHdoZW4gdXBkYXRpbmcgbWV0YSBpbmZvIGFzIHRoZSByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzXG5cdCAgICogYWN0aW9uIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyIHRha2VzIHBsYWNlLlxuXHQgICAqXG5cdCAgICogQ3JlZGl0IHRvIFtTw6liYXN0aWVuIENob3Bpbl0oaHR0cHM6Ly9naXRodWIuY29tL0F0aW51eCkgZm9yIHRoZSBzdWdnZXN0aW9uXG5cdCAgICogdG8gaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuXHQgICAqXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSAtIG5ldyBtZXRhIGluZm9cblx0ICAgKi9cblx0ICByZXR1cm4gZnVuY3Rpb24gcmVmcmVzaCAoKSB7XG5cdCAgICB2YXIgaW5mbyA9IF9nZXRNZXRhSW5mbyhvcHRpb25zKSh0aGlzLiRyb290KTtcblx0ICAgIF91cGRhdGVDbGllbnRNZXRhSW5mbyhvcHRpb25zKS5jYWxsKHRoaXMsIGluZm8pO1xuXHQgICAgcmV0dXJuIGluZm9cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBfJG1ldGEgKG9wdGlvbnMpIHtcblx0ICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgYW4gaW5qZWN0b3IgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cblx0ICAgKiBAdGhpcyB7T2JqZWN0fSAtIHRoZSBWdWUgaW5zdGFuY2UgKGEgcm9vdCBjb21wb25lbnQpXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSAtIGluamVjdG9yXG5cdCAgICovXG5cdCAgcmV0dXJuIGZ1bmN0aW9uICRtZXRhICgpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGluamVjdDogX2luamVjdChvcHRpb25zKS5iaW5kKHRoaXMpLFxuXHQgICAgICByZWZyZXNoOiBfcmVmcmVzaChvcHRpb25zKS5iaW5kKHRoaXMpXG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0Ly8gZmFsbGJhY2sgdG8gdGltZXJzIGlmIHJBRiBub3QgcHJlc2VudFxuXHR2YXIgc3RvcFVwZGF0ZSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA6IG51bGwpIHx8IGNsZWFyVGltZW91dDtcblx0dmFyIHN0YXJ0VXBkYXRlID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IG51bGwpIHx8IChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIHNldFRpbWVvdXQoY2IsIDApOyB9KTtcblxuXHQvKipcblx0ICogUGVyZm9ybXMgYSBiYXRjaGVkIHVwZGF0ZS4gVXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gcHJldmVudFxuXHQgKiBjYWxsaW5nIGEgZnVuY3Rpb24gdG9vIG1hbnkgdGltZXMgaW4gcXVpY2sgc3VjY2Vzc2lvbi5cblx0ICogWW91IG5lZWQgdG8gcGFzcyBpdCBhbiBJRCAod2hpY2ggY2FuIGluaXRpYWxseSBiZSBgbnVsbGApLFxuXHQgKiBidXQgYmUgc3VyZSB0byBvdmVyd3JpdGUgdGhhdCBJRCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgYmF0Y2hVcGRhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSAgeyhudWxsfE51bWJlcil9IGlkIC0gdGhlIElEIG9mIHRoaXMgdXBkYXRlXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHRoZSB1cGRhdGUgdG8gcGVyZm9ybVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGlkIC0gYSBuZXcgSURcblx0ICovXG5cdGZ1bmN0aW9uIGJhdGNoVXBkYXRlIChpZCwgY2FsbGJhY2spIHtcblx0ICBzdG9wVXBkYXRlKGlkKTtcblx0ICByZXR1cm4gc3RhcnRVcGRhdGUoZnVuY3Rpb24gKCkge1xuXHQgICAgaWQgPSBudWxsO1xuXHQgICAgY2FsbGJhY2soKTtcblx0ICB9KVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZXNlIGFyZSBjb25zdGFudCB2YXJpYWJsZXMgdXNlZCB0aHJvdWdob3V0IHRoZSBhcHBsaWNhdGlvbi5cblx0ICovXG5cblx0Ly8gVGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IG9wdGlvbiB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdGhhdFxuXHQvLyBnZXRzIGNvbnZlcnRlZCB0byB0aGUgdmFyaW91cyBtZXRhIHRhZ3MgJiBhdHRyaWJ1dGVzIGZvciB0aGUgcGFnZS5cblx0dmFyIFZVRV9NRVRBX0tFWV9OQU1FID0gJ21ldGFJbmZvJztcblxuXHQvLyBUaGlzIGlzIHRoZSBhdHRyaWJ1dGUgdnVlLW1ldGEgYXVnbWVudHMgb24gZWxlbWVudHMgdG8ga25vdyB3aGljaCBpdCBzaG91bGRcblx0Ly8gbWFuYWdlIGFuZCB3aGljaCBpdCBzaG91bGQgaWdub3JlLlxuXHR2YXIgVlVFX01FVEFfQVRUUklCVVRFID0gJ2RhdGEtdnVlLW1ldGEnO1xuXG5cdC8vIFRoaXMgaXMgdGhlIGF0dHJpYnV0ZSB0aGF0IGdvZXMgb24gdGhlIGBodG1sYCB0YWcgdG8gaW5mb3JtIGB2dWUtbWV0YWBcblx0Ly8gdGhhdCB0aGUgc2VydmVyIGhhcyBhbHJlYWR5IGdlbmVyYXRlZCB0aGUgbWV0YSB0YWdzIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdHZhciBWVUVfTUVUQV9TRVJWRVJfUkVOREVSRURfQVRUUklCVVRFID0gJ2RhdGEtdnVlLW1ldGEtc2VydmVyLXJlbmRlcmVkJztcblxuXHQvLyBUaGlzIGlzIHRoZSBwcm9wZXJ0eSB0aGF0IHRlbGxzIHZ1ZS1tZXRhIHRvIG92ZXJ3cml0ZSAoaW5zdGVhZCBvZiBhcHBlbmQpXG5cdC8vIGFuIGl0ZW0gaW4gYSB0YWcgbGlzdC4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIHR3byBgbWV0YWAgdGFnIGxpc3QgaXRlbXNcblx0Ly8gdGhhdCBib3RoIGhhdmUgYHZtaWRgIG9mIFwiZGVzY3JpcHRpb25cIiwgdGhlbiB2dWUtbWV0YSB3aWxsIG92ZXJ3cml0ZSB0aGVcblx0Ly8gc2hhbGxvd2VzdCBvbmUgd2l0aCB0aGUgZGVlcGVzdCBvbmUuXG5cdHZhciBWVUVfTUVUQV9UQUdfTElTVF9JRF9LRVlfTkFNRSA9ICd2bWlkJztcblxuXHQvLyBUaGlzIGlzIHRoZSBrZXkgbmFtZSBmb3IgcG9zc2libGUgbWV0YSB0ZW1wbGF0ZXNcblx0dmFyIFZVRV9NRVRBX1RFTVBMQVRFX0tFWV9OQU1FID0gJ3RlbXBsYXRlJztcblxuXHQvLyBUaGlzIGlzIHRoZSBrZXkgbmFtZSBmb3IgdGhlIGNvbnRlbnQtaG9sZGluZyBwcm9wZXJ0eVxuXHR2YXIgVlVFX01FVEFfQ09OVEVOVF9LRVkgPSAnY29udGVudCc7XG5cblx0Ly8gYXV0b21hdGljIGluc3RhbGxcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuVnVlICE9PSAndW5kZWZpbmVkJykge1xuXHQgIFZ1ZS51c2UoVnVlTWV0YSk7XG5cdH1cblxuXHQvKipcblx0ICogUGx1Z2luIGluc3RhbGwgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFZ1ZSAtIHRoZSBWdWUgY29uc3RydWN0b3IuXG5cdCAqL1xuXHRmdW5jdGlvbiBWdWVNZXRhIChWdWUsIG9wdGlvbnMpIHtcblx0ICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgIC8vIHNldCBzb21lIGRlZmF1bHQgb3B0aW9uc1xuXHQgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0ICAgIGtleU5hbWU6IFZVRV9NRVRBX0tFWV9OQU1FLFxuXHQgICAgY29udGVudEtleU5hbWU6IFZVRV9NRVRBX0NPTlRFTlRfS0VZLFxuXHQgICAgbWV0YVRlbXBsYXRlS2V5TmFtZTogVlVFX01FVEFfVEVNUExBVEVfS0VZX05BTUUsXG5cdCAgICBhdHRyaWJ1dGU6IFZVRV9NRVRBX0FUVFJJQlVURSxcblx0ICAgIHNzckF0dHJpYnV0ZTogVlVFX01FVEFfU0VSVkVSX1JFTkRFUkVEX0FUVFJJQlVURSxcblx0ICAgIHRhZ0lES2V5TmFtZTogVlVFX01FVEFfVEFHX0xJU1RfSURfS0VZX05BTUVcblx0ICB9O1xuXHQgIC8vIGNvbWJpbmUgb3B0aW9uc1xuXHQgIG9wdGlvbnMgPSBvYmplY3RBc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG5cdCAgLy8gYmluZCB0aGUgJG1ldGEgbWV0aG9kIHRvIHRoaXMgY29tcG9uZW50IGluc3RhbmNlXG5cdCAgVnVlLnByb3RvdHlwZS4kbWV0YSA9IF8kbWV0YShvcHRpb25zKTtcblxuXHQgIC8vIHN0b3JlIGFuIGlkIHRvIGtlZXAgdHJhY2sgb2YgRE9NIHVwZGF0ZXNcblx0ICB2YXIgYmF0Y2hJRCA9IG51bGw7XG5cblx0ICAvLyB3YXRjaCBmb3IgY2xpZW50IHNpZGUgY29tcG9uZW50IHVwZGF0ZXNcblx0ICBWdWUubWl4aW4oe1xuXHQgICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuXHQgICAgICAvLyBBZGQgYSBtYXJrZXIgdG8ga25vdyBpZiBpdCB1c2VzIG1ldGFJbmZvXG5cdCAgICAgIC8vIF92bm9kZSBpcyB1c2VkIHRvIGtub3cgdGhhdCBpdCdzIGF0dGFjaGVkIHRvIGEgcmVhbCBjb21wb25lbnRcblx0ICAgICAgLy8gdXNlZnVsIGlmIHdlIHVzZSBzb21lIG1peGluIHRvIGFkZCBzb21lIG1ldGEgdGFncyAobGlrZSBudXh0LWkxOG4pXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy4kb3B0aW9uc1tvcHRpb25zLmtleU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHRoaXMuX2hhc01ldGFJbmZvID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBjb2VyY2UgZnVuY3Rpb24tc3R5bGUgbWV0YUluZm8gdG8gYSBjb21wdXRlZCBwcm9wIHNvIHdlIGNhbiBvYnNlcnZlXG5cdCAgICAgIC8vIGl0IG9uIGNyZWF0aW9uXG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy4kb3B0aW9uc1tvcHRpb25zLmtleU5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzLiRvcHRpb25zLmNvbXB1dGVkID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgdGhpcy4kb3B0aW9ucy5jb21wdXRlZCA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLiRvcHRpb25zLmNvbXB1dGVkLiRtZXRhSW5mbyA9IHRoaXMuJG9wdGlvbnNbb3B0aW9ucy5rZXlOYW1lXTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuXHQgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgICAvLyBpZiBjb21wdXRlZCAkbWV0YUluZm8gZXhpc3RzLCB3YXRjaCBpdCBmb3IgdXBkYXRlcyAmIHRyaWdnZXIgYSByZWZyZXNoXG5cdCAgICAgIC8vIHdoZW4gaXQgY2hhbmdlcyAoaS5lLiBhdXRvbWF0aWNhbGx5IGhhbmRsZSBhc3luYyBhY3Rpb25zIHRoYXQgYWZmZWN0IG1ldGFJbmZvKVxuXHQgICAgICAvLyBjcmVkaXQgZm9yIHRoaXMgc3VnZ2VzdGlvbiBnb2VzIHRvIFtTw6liYXN0aWVuIENob3Bpbl0oaHR0cHM6Ly9naXRodWIuY29tL0F0aW51eClcblx0ICAgICAgaWYgKCF0aGlzLiRpc1NlcnZlciAmJiB0aGlzLiRtZXRhSW5mbykge1xuXHQgICAgICAgIHRoaXMuJHdhdGNoKCckbWV0YUluZm8nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAvLyBiYXRjaCBwb3RlbnRpYWwgRE9NIHVwZGF0ZXMgdG8gcHJldmVudCBleHRyYW5lb3VzIHJlLXJlbmRlcmluZ1xuXHQgICAgICAgICAgYmF0Y2hJRCA9IGJhdGNoVXBkYXRlKGJhdGNoSUQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS4kbWV0YSgpLnJlZnJlc2goKTsgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGFjdGl2YXRlZCAoKSB7XG5cdCAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICAgIGlmICh0aGlzLl9oYXNNZXRhSW5mbykge1xuXHQgICAgICAgIC8vIGJhdGNoIHBvdGVudGlhbCBET00gdXBkYXRlcyB0byBwcmV2ZW50IGV4dHJhbmVvdXMgcmUtcmVuZGVyaW5nXG5cdCAgICAgICAgYmF0Y2hJRCA9IGJhdGNoVXBkYXRlKGJhdGNoSUQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS4kbWV0YSgpLnJlZnJlc2goKTsgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gZGVhY3RpdmF0ZWQgKCkge1xuXHQgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgICBpZiAodGhpcy5faGFzTWV0YUluZm8pIHtcblx0ICAgICAgICAvLyBiYXRjaCBwb3RlbnRpYWwgRE9NIHVwZGF0ZXMgdG8gcHJldmVudCBleHRyYW5lb3VzIHJlLXJlbmRlcmluZ1xuXHQgICAgICAgIGJhdGNoSUQgPSBiYXRjaFVwZGF0ZShiYXRjaElELCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuJG1ldGEoKS5yZWZyZXNoKCk7IH0pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcblx0ICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgICAgLy8gYmF0Y2ggcG90ZW50aWFsIERPTSB1cGRhdGVzIHRvIHByZXZlbnQgZXh0cmFuZW91cyByZS1yZW5kZXJpbmdcblx0ICAgICAgaWYgKHRoaXMuX2hhc01ldGFJbmZvKSB7XG5cdCAgICAgICAgYmF0Y2hJRCA9IGJhdGNoVXBkYXRlKGJhdGNoSUQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS4kbWV0YSgpLnJlZnJlc2goKTsgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG5cdCAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICAgIC8vIGRvIG5vdCB0cmlnZ2VyIHJlZnJlc2ggb24gdGhlIHNlcnZlciBzaWRlXG5cdCAgICAgIGlmICh0aGlzLiRpc1NlcnZlcikgeyByZXR1cm4gfVxuXHQgICAgICAvLyByZS1yZW5kZXIgbWV0YSBkYXRhIHdoZW4gcmV0dXJuaW5nIGZyb20gYSBjaGlsZCBjb21wb25lbnQgdG8gcGFyZW50XG5cdCAgICAgIGlmICh0aGlzLl9oYXNNZXRhSW5mbykge1xuXHQgICAgICAgIC8vIFdhaXQgdGhhdCBlbGVtZW50IGlzIGhpZGRlbiBiZWZvcmUgcmVmcmVzaGluZyBtZXRhIHRhZ3MgKHRvIHN1cHBvcnQgYW5pbWF0aW9ucylcblx0ICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAodGhpcyQxLiRlbCAmJiB0aGlzJDEuJGVsLm9mZnNldFBhcmVudCAhPT0gbnVsbCkgeyByZXR1cm4gfVxuXHQgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdCAgICAgICAgICBpZiAoIXRoaXMkMS4kcGFyZW50KSB7IHJldHVybiB9XG5cdCAgICAgICAgICBiYXRjaElEID0gYmF0Y2hVcGRhdGUoYmF0Y2hJRCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLiRtZXRhKCkucmVmcmVzaCgpOyB9KTtcblx0ICAgICAgICB9LCA1MCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXG5cdHZhciB2ZXJzaW9uID0gXCIxLjUuOFwiO1xuXG5cdFZ1ZU1ldGEudmVyc2lvbiA9IHZlcnNpb247XG5cblx0cmV0dXJuIFZ1ZU1ldGE7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-meta/lib/vue-meta.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n/* harmony import */ var bootstrap_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap-vue */ \"./node_modules/bootstrap-vue/es/index.js\");\n/* harmony import */ var bootstrap_vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bootstrap_vue__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bootstrap_dist_css_bootstrap_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.css */ \"./node_modules/bootstrap/dist/css/bootstrap.css\");\n/* harmony import */ var bootstrap_dist_css_bootstrap_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bootstrap_dist_css_bootstrap_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var bootstrap_vue_dist_bootstrap_vue_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bootstrap-vue/dist/bootstrap-vue.css */ \"./node_modules/bootstrap-vue/dist/bootstrap-vue.css\");\n/* harmony import */ var bootstrap_vue_dist_bootstrap_vue_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bootstrap_vue_dist_bootstrap_vue_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var vue_meta__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue-meta */ \"./node_modules/vue-meta/lib/vue-meta.js\");\n/* harmony import */ var vue_meta__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vue_meta__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _App_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./App.vue */ \"./src/App.vue\");\n\n\n\n\n\n\nvue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use(bootstrap_vue__WEBPACK_IMPORTED_MODULE_1___default.a);\nvue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use(vue_meta__WEBPACK_IMPORTED_MODULE_4___default.a);\nvue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].config.productionTip = false;\nnew vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n  render: function render(h) {\n    return h(_App_vue__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n  }\n}).$mount('#app');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQm9vdHN0cmFwVnVlIGZyb20gJ2Jvb3RzdHJhcC12dWUnO1xuaW1wb3J0ICdib290c3RyYXAvZGlzdC9jc3MvYm9vdHN0cmFwLmNzcyc7XG5pbXBvcnQgJ2Jvb3RzdHJhcC12dWUvZGlzdC9ib290c3RyYXAtdnVlLmNzcyc7XG5pbXBvcnQgTWV0YSBmcm9tICd2dWUtbWV0YSc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJ1xuXG5WdWUudXNlKEJvb3RzdHJhcFZ1ZSlcblZ1ZS51c2UoTWV0YSlcblxuVnVlLmNvbmZpZy5wcm9kdWN0aW9uVGlwID0gZmFsc2VcblxubmV3IFZ1ZSh7XG4gIHJlbmRlcjogaCA9PiBoKEFwcCksXG59KS4kbW91bnQoJyNhcHAnKVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

})